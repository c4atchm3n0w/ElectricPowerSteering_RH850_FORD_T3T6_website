---
title: XCP_ReferenceBook_V2.0_ENs
linkTitle: XCP_ReferenceBook_V2.0_ENs
weight: 18
---

<!DOCTYPE html><html>
<head>
<title></title>
<style type="text/css">
<!--
.xflip {
    -moz-transform: scaleX(-1);
    -webkit-transform: scaleX(-1);
    -o-transform: scaleX(-1);
    transform: scaleX(-1);
    filter: fliph;
}
.yflip {
    -moz-transform: scaleY(-1);
    -webkit-transform: scaleY(-1);
    -o-transform: scaleY(-1);
    transform: scaleY(-1);
    filter: flipv;
}
.xyflip {
    -moz-transform: scaleX(-1) scaleY(-1);
    -webkit-transform: scaleX(-1) scaleY(-1);
    -o-transform: scaleX(-1) scaleY(-1);
    transform: scaleX(-1) scaleY(-1);
    filter: fliph + flipv;
}
-->
</style>
</head>
<body>
<a name=1></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-1_1.png"/><br/>
<b>XCP – The Standard Protocol<br/>for ECU Development</b><br/>
<b>Fundamentals and Application Areas</b><br/>
Andreas Patzer | Rainer Zaiser<br/>
<hr/>
<a name=2></a><b>Andreas Patzer&#160;| Rainer Zaiser</b><br/>
<b>XCP – The Standard Protocol for ECU Development</b><br/>
<hr/>
<a name=3></a>Date April 2014 | Reproduction only with expressed permission from &#160;<br/>
Vector Informatik GmbH, Ingersheimer Str. 24, 70499 Stuttgart, Germany<br/>
© 2014 by Vector Informatik GmbH. All rights reserved. This book is only intended for personal use, but not for technical or &#160;<br/>
commercial use. It may not be used as a basis for contracts of any kind. All information in this book was compiled with the &#160;<br/>
greatest possible care, but Vector Informatik does not assume any guarantee or warranty whatsoever for the correctness of the &#160;<br/>
information it contains. The liability of Vector Informatik is excluded, except for malicious intent or gross negligence, to the extent &#160;<br/>
that laws do not make it legally liable.&#160;<br/>
&#160;&#160;<br/>
Information contained in this book may be protected by copyright and&#160;/&#160;or patent rights. Product names of software, hardware and &#160;<br/>
other product names that are used in this book may be registered brands or otherwise protected by branding laws, regardless of &#160;<br/>
whether or not they are identified as registered brands.<br/>
<hr/>
<a name=4></a><b>XCP –&#160;</b><br/>
<b>The Standard Protocol</b><br/>
<b>for ECU Development</b><br/>
<b>Fundamentals and Application&#160;Areas</b><br/>
Andreas Patzer, Rainer Zaiser&#160;<br/>
Vector Informatik GmbH<br/>
<hr/>
<a name=5></a><b>Table of Contents&#160;&#160;</b><br/>
<b>Introduction</b>&#160;<br/>
7<br/>
<b>1&#160;&#160;Fundamentals of the XCP Protocol&#160;</b><br/>
13<br/>
<b>1.1&#160;&#160;XCP Protocol Layer</b>&#160;<br/>
19<br/>
&#160;<br/>
1.1.1&#160;&#160;Identification&#160;Field<b>&#160;</b><br/>
21<br/>
<b>&#160;</b><br/>
1.1.2&#160;&#160;Time Stamp<b>&#160;</b><br/>
21<br/>
<b>&#160;</b><br/>
1.1.3&#160;&#160;Data Field<b>&#160;</b><br/>
22<br/>
<b>1.2&#160;&#160;Exchange of&#160;CTOs&#160;</b><br/>
22<br/>
<b>&#160;</b><br/>
1.2.1&#160;&#160;XCP Command&#160;Structure<b>&#160;</b><br/>
22<br/>
<b>&#160;</b><br/>
1.2.2&#160;CMD&#160;<br/>
25<br/>
&#160;<br/>
1.2.3&#160;RES&#160;<br/>
28<br/>
&#160;<br/>
1.2.4&#160;ERR&#160;<br/>
28<br/>
&#160;<br/>
1.2.5&#160;EV&#160;<br/>
29<br/>
&#160;<br/>
1.2.6&#160;SERV&#160;<br/>
29<br/>
&#160;<br/>
1.2.7&#160;&#160;Calibrating Parameters in the Slave<b>&#160;</b><br/>
29<br/>
<b>1.3&#160;&#160;Exchanging&#160;DTOs – Synchronous Data Exchange&#160;</b><br/>
32<br/>
<b>&#160;</b><br/>
1.3.1&#160;&#160;Measurement&#160;Methods: Polling&#160;versus DAQ<b>&#160;</b><br/>
33<br/>
<b>&#160;</b><br/>
1.3.2&#160;&#160;DAQ Measurement Method&#160;<br/>
34<br/>
&#160;<br/>
1.3.3&#160;&#160;STIM Calibration Method&#160;<br/>
41<br/>
&#160;<br/>
1.3.4&#160;&#160;XCP Packet Addressing for DAQ and STIM&#160;<br/>
42<br/>
&#160;<br/>
1.3.5&#160;&#160;Bypassing = DAQ + STIM&#160;<br/>
44<br/>
<b>1.4&#160;&#160;XCP Transport Layers</b>&#160;<br/>
45<br/>
&#160;<br/>
1.4.1&#160;CAN&#160;<br/>
45<br/>
&#160;<br/>
1.4.2&#160;&#160;CAN FD&#160;<br/>
48<br/>
&#160;<br/>
1.4.3&#160;FlexRay&#160;<br/>
50<br/>
&#160;<br/>
1.4.4&#160;Ethernet&#160;<br/>
53<br/>
&#160;<br/>
1.4.5&#160;SxI&#160;<br/>
55<br/>
&#160;<br/>
1.4.6&#160;USB&#160;<br/>
55<br/>
&#160;<br/>
1.4.7&#160;LIN&#160;<br/>
55<br/>
<b>1.5&#160;&#160;XCP Services</b>&#160;<br/>
56<br/>
&#160;<br/>
1.5.1&#160;&#160;Memory&#160;Page Swapping&#160;<br/>
56<br/>
&#160;<br/>
1.5.2&#160;&#160;Saving Memory Pages – Data Page Freezing&#160;<br/>
58<br/>
&#160;<br/>
1.5.3&#160;&#160;Flash Programming&#160;<br/>
58<br/>
&#160;<br/>
1.5.4&#160;&#160;Automatic&#160;Detection of the Slave&#160;<br/>
60<br/>
&#160;<br/>
1.5.5&#160;&#160;Block&#160;Transfer Mode for Upload,&#160;Download and Flashing&#160;<br/>
61<br/>
&#160;<br/>
1.5.6&#160;&#160;Cold Start Measurement (start of measurement during power-on)&#160;<br/>
62<br/>
&#160;<br/>
1.5.7&#160;&#160;Security&#160;Mechanisms&#160;with XCP&#160;<br/>
63<br/>
<hr/>
<a name=6></a><b>2&#160;&#160;ECU Description File&#160;A2L&#160;</b><br/>
65<br/>
<b>2.1&#160;&#160;Setting&#160;Up an A2L File for&#160;an XCP Slave&#160;</b><br/>
68<br/>
<b>2.2&#160;Manually&#160;Creating an A2L File&#160;</b><br/>
69<br/>
<b>2.3&#160;A2L Contents&#160;versus ECU Implementation&#160;</b><br/>
70<br/>
<b>3&#160;&#160;Calibration Concepts&#160;</b><br/>
73<br/>
<b>3.1&#160;&#160;Parameters in&#160;Flash&#160;</b><br/>
74<br/>
<b>3.2&#160;Parameters in&#160;RAM&#160;</b><br/>
76<br/>
<b>3.3&#160;Flash Overlay&#160;</b><br/>
78<br/>
<b>3.4&#160;Dynamic&#160;Flash Overlay&#160;Allocation&#160;</b><br/>
79<br/>
<b>3.5&#160;RAM Pointer&#160;Based Calibration&#160;Concept per AUTOSAR&#160;</b><br/>
80<br/>
<b>&#160;</b><br/>
3.5.1 Single Pointer Concept&#160;<br/>
80<br/>
&#160;<br/>
3.5.2 Double Pointer Concept<b>&#160;</b><br/>
82<br/>
<b>3.6&#160;Flash Pointer Based Calibration Concept&#160;</b><br/>
83<br/>
<b>4&#160;&#160;Application&#160;Areas of XCP&#160;</b><br/>
85<br/>
<b>4.1&#160;&#160;MIL: Model&#160;in the Loop&#160;</b><br/>
87<br/>
<b>4.2&#160;SIL: Software in the Loop&#160;</b><br/>
88<br/>
<b>4.3&#160;HIL:&#160;Hardware in the Loop&#160;</b><br/>
89<br/>
<b>4.4&#160;RCP: Rapid Control Prototyping&#160;</b><br/>
91<br/>
<b>4.5&#160;Bypassing&#160;</b><br/>
92<br/>
<b>4.6&#160;Shortening&#160;Iteration&#160;Cycles with Virtual ECUs&#160;</b><br/>
95<br/>
<b>5&#160;&#160;Example of an&#160;XCP Implementation&#160;</b><br/>
99<br/>
<b>5.1&#160;&#160;Description of Functions&#160;</b><br/>
102<br/>
<b>5.2&#160;Parameterization of the Driver</b>&#160;<br/>
104<br/>
<b>The Authors&#160;</b><br/>
106<br/>
<b>Table of Abbreviations&#160;and Acronyms&#160;</b><br/>
108<br/>
<b>Literature&#160;</b><br/>
109<br/>
<b>Web Addresses&#160;</b><br/>
109<br/>
<b>Table of Figures&#160;</b><br/>
110<br/>
<b>Appendix – XCP Solutions at Vector&#160;</b><br/>
112<br/>
<b>Index&#160;</b><br/>
114<br/>
<hr/>
<a name=7></a>Introduction<br/>
7<br/>
<b>Introduction</b><br/>
In optimal parameterization (calibration) of electronic ECUs, you calibrate parameter values&#160;<br/>during the system runtime and simultaneously acquire measured signals. The physical connec-<br/>tion between the development tool and the ECU is via a measurement and calibration protocol.&#160;<br/>XCP has become&#160;established as a&#160;standard here.<br/>First, the fundamentals and mechanisms of XCP will be explained briefly and then the applica-<br/>tion areas and&#160;added value for ECU calibration will&#160;be discussed.<br/>
First,&#160;some facts about XCP:<br/>&gt;&#160;&#160;XCP signifies “Universal Measurement and Calibration Protocol”. The “X” stands for the vari-<br/>
able and interchangeable transport layer.<br/>
&gt;&#160;&#160;&#160;It was standardized by an ASAM working committee (Association for Standardisation of Auto-<br/>
mation and Measuring Systems). ASAM is an organization of automotive OEMs, suppliers and&#160;<br/>tool producers.<br/>
&gt;&#160;&#160;XCP is the protocol that succeeds&#160;CCP (CAN Calibration Protocol).<br/>&gt;&#160;&#160;The conceptual&#160;idea of the CAN Calibration Protocol&#160;was to permit read and write access&#160;to&#160;<br/>
internal ECU data over CAN. XCP was developed to implement this capability via different&#160;<br/>transmission&#160;media. Then&#160;one speaks of XCP on&#160;CAN, XCP on FlexRay or XCP on Ethernet.&#160;<br/>
&gt;&#160;&#160;&#160;The primary applications of XCP are measurement and calibration of internal ECU parameters.&#160;<br/>
Here,&#160;the&#160;protocol&#160;offers the ability&#160;to&#160;acquire measured values&#160;“event&#160;synchronous”&#160;to&#160;pro-<br/>cesses in&#160;ECUs. This ensures consistency of the&#160;data between one another.<br/>
To visualize the underlying idea, we initially view the ECU and the software running in it as&#160;<br/>a&#160;black&#160;box.&#160;In&#160;a&#160;black&#160;box,&#160;only&#160;the&#160;inputs&#160;into&#160;the&#160;ECU&#160;(e.g.&#160;CAN&#160;messages&#160;and&#160;sensor&#160;val-<br/>ues) and the output from the ECU (e.g. CAN messages and actuator drives) are acquired. Details&#160;<br/>about the internal processing of algorithms are not immediately apparent and can only be&#160;<br/>determined&#160;from an analysis of the input and&#160;output data.&#160;<br/>
Now imagine that you had a look into the behavior of your ECU with every computation cycle. At&#160;<br/>any time, you could acquire detailed information on how the algorithm is running. You would&#160;<br/>no longer have a black box, but a white box instead with a full view of internal processes. That&#160;<br/>is precisely what you get with XCP!&#160;<br/>
What contribution can XCP make for the overall development process? To check the functional-<br/>ity of the attained development status, the developer can execute the code repeatedly. In this&#160;<br/>way, the developer finds out how the algorithm behaves and what might be optimized. It does&#160;<br/>not matter here whether a compiled code runs on a specific hardware or whether it is developed&#160;<br/>in a model-based&#160;way and the application&#160;runs in&#160;the form of a&#160;model.<br/>
A central focus is on the evaluation of the algorithm process. For example, if the algorithm is&#160;<br/>running as&#160;a model in a&#160;development environment,&#160;such as&#160;Simulink from&#160;The MathWorks, it&#160;<br/>is helpful to developers if they can also acquire intermediate results to their applications, in&#160;<br/>order to obtain findings about other changes. In the final analysis, this method enables noth-<br/>ing other than read access to parameters so that they can be visualized and analyzed – and&#160;all&#160;<br/>of&#160;this&#160;at model&#160;runtime&#160;or&#160;retrospectively&#160;after&#160;a time-limited test&#160;run&#160;has been&#160;completed.&#160;A&#160;<br/>write access is needed if parameterizations are changed, e.g. if the proportional component of a&#160;<br/>
<hr/>
<a name=8></a>8<br/>
Introduction<br/>
PID controller is modified to adapt the algorithm behavior to the system under control. Regard-<br/>less of where your application runs – focal points are always the detailed analysis of algorithm&#160;<br/>processes&#160;and optimization by changes to the parameterization.<br/>
This generalization can be made: The algorithms may exist in any type of executable form (code&#160;<br/>or model description). Different systems may be used as the runtime environment (Simulink,&#160;<br/>as&#160;DLL&#160;on&#160;the&#160;PC,&#160;on&#160;a&#160;rapid&#160;prototyping&#160;platform,&#160;in&#160;the&#160;ECU&#160;etc.).&#160;Process&#160;flows&#160;are&#160;analyzed&#160;<br/>by read access to data and acquisition of its time-based flow. Parameter sets are modified iter-<br/>atively&#160;to&#160;optimize&#160;algorithms.&#160;To&#160;simplify&#160;the&#160;representation,&#160;the&#160;acquisition&#160;of&#160;data&#160;can&#160;be&#160;<br/>externalized to an external PC-based tool, although it is understood here that runtime environ-<br/>ments themselves can even offer analysis&#160;capabilities.<br/>
Runtime Environment<br/>
Application<br/>
<b>Figure 1:&#160;</b><br/>
Communication<br/>
PC Tool<br/>
<b>Fundamental&#160;&#160;</b><br/>
Operating System<br/>
<b>communication&#160;&#160;<br/>with a runtime&#160;<br/>environment</b><br/>
The type of runtime environment and the form of communication generally differ from one&#160;<br/>another considerably. The reason is that the runtime environments are developed by different&#160;<br/>producers and are based on different solution approaches. Different types of protocols, con-<br/>figurations, measurement data formats, etc. make it a futile effort to try to exchange parame-<br/>ter sets and results in all development steps. In the end, however, all of these solutions can be&#160;<br/>reduced to read and write access&#160;at runtime. And there is a standard for&#160;this: XCP.<br/>
XCP is an ASAM standard whose Version 1.0 was released in 2003. The acronym ASAM stands&#160;<br/>for “Association for Standardisation of Automation and Measuring Systems.” Suppliers, vehicle&#160;<br/>OEMs&#160;and&#160;tool&#160;manufacturers&#160;are&#160;all&#160;represented&#160;in&#160;the&#160;ASAM&#160;working&#160;group.&#160;The&#160;purpose&#160;of&#160;the&#160;<br/>XCP working group is to define a generalized measurement and calibration protocol that can be&#160;<br/>used independent of the specific transport medium. Experience gained from working with CCP&#160;<br/>(CAN&#160;Calibration Protocol)&#160;flowed into the&#160;development as well.<br/>
XCP was defined based on the ASAM interfaces model. The following figure shows a measure-<br/>ment and calibration tool’s interfaces to the XCP Slave, to the description file and the connec-<br/>tion to a&#160;higher-level automation&#160;system.&#160;<br/>
<hr/>
<a name=9></a>Introduction<br/>
9<br/>
Upper Level<br/>
Automation System<br/>
ASAM MCD 3MC<br/>
Measurement and<br/>
ASAM<br/>
Calibration System<br/>
MCD 2MC<br/>
*.a2L&#160;<br/>
XCP Driver<br/>
ECU Description File<br/>
ASAM MCD 1MC<br/>
XCP Driver<br/>
ECU&#160;<br/>
<b>Figure 2:<br/>The Interface Model&#160;<br/>of ASAM</b><br/>
<b>Interface 1: “ASAM MCD-1 MC” between the ECU and the measurement and calibration system<br/></b>This interface describes the physical and the protocol-specific parts. Strictly speaking, a dis-<br/>tinction was made between interfaces ASAP1a and ASAP1b here. The ASAP1b interface, how-<br/>ever, never received general acceptance and for all practical purposes it has no relevance today.&#160;<br/>The XCP protocol is so flexible that it can practically assume the role of a general manufacturer-<br/>independent interface. For example, today all measurement and calibration hardware manufac-<br/>turers offer systems (xETK, VX1000, etc.) which can be connected via the XCP on Ether&#160;net stan-<br/>dard. An ASAP1b&#160;interface –&#160;as it was still&#160;described for&#160;CCP – is no longer necessary.&#160;<br/>
<b>Interface 2: “ASAM MCD-2&#160;MC” A2L ECU description file&#160;<br/></b>As already mentioned, XCP works in an address-oriented way. Read or write accesses to objects&#160;<br/>are&#160;always&#160;based&#160;on&#160;an&#160;address&#160;entry.&#160;Ultimately,&#160;however,&#160;this&#160;would&#160;mean&#160;that&#160;the&#160;user&#160;would&#160;<br/>have to search&#160;for his ECU objects in the Master based on the&#160;address. That would be extremely&#160;<br/>inconvenient. To let users work with symbolic object names, for example, a file is needed that&#160;<br/>describes the relationship between the object name and the object address. The next chapter is&#160;<br/>devoted to this A2L description file.<br/>
<b>Interface 3: “ASAM MCD-3&#160;MC” automation interface&#160;<br/></b>This interface is used to connect another system to the measurement and calibration tool, e.g.&#160;<br/>for test bench automation. The interface is not further explained in this document, because it is&#160;<br/>irrelevant&#160;to understanding XCP.&#160;<br/>
<hr/>
<a name=10></a>10<br/>
Introduction<br/>
XCP is based on the Master-Slave principle. The ECU is the Slave and the measurement and cali-<br/>bration tool is the Master. A Slave may only communicate with one Master at any given time; on&#160;<br/>the other hand, the Master&#160;can simultaneous communicate with many Slaves.<br/>
Master<br/>
Bus<br/>
<b>Figure 3:<br/>An XCP Master can&#160;<br/>simultaneously&#160;&#160;</b><br/>
Slave<br/>
Slave<br/>
Slave<br/>
Slave<br/>
<b>communicate with&#160;&#160;<br/>multiple Slaves</b><br/>
To be able to access data and configurations over the entire development process, XCP must&#160;<br/>be used in every runtime environment. Fewer tools would need to be purchased, operated and&#160;<br/>maintained. This would also eliminate the need for manual copying of configurations from one&#160;<br/>tool to another, a process that is susceptible to errors. This would simplify iterative loops, in&#160;<br/>which results from later work steps are transferred back to prior work steps.&#160;<br/>
But let us turn our attention away from what might be feasible to what is possible today: every-<br/>thing! XCP solutions are already used in a wide variety of work environments. It is the intention&#160;<br/>of this book to describe the main properties of the measurement and calibration protocol and&#160;<br/>introduce its use in the various runtime environments. What you will not find in this book: nei-<br/>ther the entire XCP specification in detailed form, nor precise instructions for integrating XCP&#160;<br/>drivers in a specific runtime environment. It explains the relationships, but not the individual&#160;<br/>protocol and implementation details. Internet links in the appendix refer to openly available&#160;<br/>XCP driver source code and sample implementations, which let you understand and see how the&#160;<br/>implementation is made.&#160;<br/>
Screenshots of the PC tool used in this book were prepared using the CANape measurement and&#160;<br/>calibration tool from Vector. Other process flows are also explained based on CANape, including&#160;<br/>how to create an A2L file and even more. With a cost-free demo version, which is available to you&#160;<br/>in&#160;the&#160;Download&#160;Center&#160;of the&#160;Vector&#160;website&#160;at&#160;www.vector.com/canape_demo, you can&#160;see for&#160;<br/>yourself.<br/>
<hr/>
<a name=11></a>Introduction<br/>
11<br/>
<hr/>
<a name=12></a>12<br/>
<hr/>
<a name=13></a>1 Fundamentals of the XCP Protocol<br/>
13<br/>
<b>1 Fundamentals of the XCP Protocol</b><br/>
<hr/>
<a name=14></a>14<br/>
1 Fundamentals of the XCP Protocol<br/>
Interface 1 of the ASAM interfaces model describes sending and receiving commands and data&#160;<br/>between the Slave and the Master. To achieve independence from a specific physical transport&#160;<br/>layer,&#160;XCP was subdivided into&#160;a protocol layer and&#160;a transport layer.&#160;<br/>
CAN<br/>
Ethernet<br/>
FlexRay<br/>
SxI<br/>
USB<br/>
...<br/>
<b>Figure 4: Subdivision of the XCP protocol into protocol layer and transport layer</b><br/>
Depending on the transport layer, one refers to XCP on CAN, XCP on Ethernet, etc. The extend-<br/>ibility to new transport layers was proven as early as 2005 when XCP on FlexRay made its debut.&#160;<br/>The current version of the XCP protocol is Version 1.1, which was approved in&#160;2008.<br/>
Adherence to the following principles was&#160;given&#160;high priority in&#160;designing the protocol:<br/>&gt;&#160;&#160;Minimal&#160;resource usage in the ECU<br/>&gt;&#160;&#160;Efficient&#160;communication<br/>&gt;&#160;&#160;Simple&#160;Slave implementation&#160;<br/>&gt;&#160;&#160;Plug-and-play configuration with just a small&#160;number of parameters<br/>&gt;&#160;&#160;Scalability<br/>
<hr/>
<a name=15></a>1 Fundamentals of the XCP Protocol<br/>
15<br/>
A key&#160;functionality of XCP&#160;is that it enables&#160;read and write access to the memory of the&#160;Slave.&#160;<br/>
Read access lets users measure the time response of an internal ECU parameter. ECUs&#160;are sys-<br/>tems with discrete time behavior, whose parameters only change at specific time intervals: only&#160;<br/>when the processor recalculates the value and updates it in RAM. One of the great strengths of&#160;<br/>XCP lies in acquiring measured values from RAM which change synchronously to process flows&#160;<br/>or events in the ECU. This lets users evaluate direct relationships between time-based process&#160;<br/>flows in the ECU and the changing values. These are referred to as event-synchronous measure-<br/>ments. The&#160;related mechanisms&#160;will be explained&#160;later in detail.<br/>
Write access lets the user optimize parameters of algorithms in the Slave. The accesses are&#160;<br/>address-oriented, i.e. the communication between Master and Slave references addresses in&#160;<br/>memory. So, the measurement of a parameter is essentially implemented as a request of the&#160;<br/>Master to the Slave: “Give me the value of memory location 0x1234”. Calibration of a parameter&#160;<br/>– the write access – to the Slave means: “Set the value at address&#160;0x9876 to 5”.<br/>
An XCP Slave does not absolutely need to be used in ECUs. It may be implemented in differ-<br/>ent environments: from a model-based development environment to hardware-in-the-loop and&#160;<br/>software-in-the-loop&#160;environments&#160;to&#160;hardware&#160;interfaces&#160;that&#160;are&#160;used&#160;to&#160;access&#160;ECU&#160;memory&#160;<br/>via debug interfaces such as&#160;JTAG, NEXUS and DAP.<br/>
Simulink<br/>
Slave<br/>
Prototype or<br/>ECU Hardware<br/>
Slave<br/>
<b>XCP</b><br/>
Measurement/<br/>Calibration&#160;<br/>
Master<br/>
Slave<br/>
PC<br/>
Hardware*<br/>
EXE/DLL<br/>
Slave<br/>
<b>Figure 5:&#160;</b><br/>
HIL/SIL Systems<br/>
<b>XCP Slaves can be&#160;</b><br/>
Slave<br/>
<b>used in many&#160;<br/>different runtime&#160;</b><br/>
* Debug Interfaces, Memory Emulator, ...<br/>
<b>environments</b><br/>
<hr/>
<a name=16></a>16<br/>
1 Fundamentals of the XCP Protocol<br/>
How can algorithms be optimized using read and write access to the ECU and what benefits&#160;<br/>does this offer? To be able to modify individual parameters at runtime in the ECU, there must be&#160;<br/>access to them. Not every type of memory permits this process. It is only possible to perform a&#160;<br/>read and write access to memory addresses in RAM (intentionally excluding the EEPROM here).&#160;<br/>The following is a brief summary of the differences between individual memory technologies:&#160;<br/>knowledge of&#160;them is very important to understanding over the further course of this book.<br/>
<b>Memory&#160;Fundamentals</b><br/>
Today, flash memories are usually integrated in the microcontroller chips for ECUs and are used&#160;<br/>for long-term storage of code&#160;and data,&#160;even without&#160;power supply.&#160;The special&#160;aspect of&#160;a flash&#160;<br/>memory is that read and write access to individual bytes is indeed possible at any time, but writ-<br/>ing of new contents can only be done&#160;blockwise, usually in rather&#160;large blocks.&#160;<br/>
Flash memories have a limited life, which is specified in terms of a maximum number of erasure&#160;<br/>cycles&#160;(depending&#160;on&#160;the&#160;specific&#160;technology&#160;the&#160;maximum&#160;may&#160;be&#160;up&#160;to&#160;one&#160;million&#160;cycles).&#160;<br/>This is also the maximum number of write cycles, because the memory must always be erased as&#160;<br/>a block before&#160;it&#160;can be&#160;written&#160;again. The&#160;reason&#160;for this&#160;lies&#160;in&#160;the memory structure: electrons&#160;<br/>are “pumped” via tunnel diodes. A bit is stored at a memory location as follows: electrons must&#160;<br/>be transported into the&#160;memory&#160;location&#160;over&#160;an electrically&#160;insulating&#160;layer. Once&#160;the&#160;elec-<br/>trons are then behind the insulating layer, they form an electric field with their charge, which is&#160;<br/>interpreted as a 1 when reading the memory location. If there are no electrons behind the layer,&#160;<br/>the cell information is interpreted as a 0. A 1 can indeed be set in this way, but not a 0. Setting&#160;<br/>to 0 (=&#160;erasing the 1) is performed in a separate erasing routine, in which electrons existing&#160;<br/>behind the insulating layer are discharged. However, for architectural reasons, such an erasing&#160;<br/>routine does not just act on single bytes, rather only on the group or block level. Depending on&#160;<br/>the architecture, blocks of 128 or 256 bytes are usually used. If one wishes to overwrite a byte&#160;<br/>within such a block, the entire block must first be erased. Then the entire contents of the block&#160;<br/>can be written back.<br/>
When this erasing routine is repeated multiple times, the insulating layer (“Tunnel Oxide Film”)&#160;<br/>can be damaged. This means that the electrons could slowly leak away, changing some of the&#160;<br/>information from 1 to 0 over the course of time. Therefore, the number of allowable flash cycles&#160;<br/>is severely limited in an ECU. In the production ECU, it is often only on the order of single digit&#160;<br/>numbers. This restriction is monitored by the Flash Boot Loader, which uses a counter to keep&#160;<br/>track&#160;of how many flash operations have&#160;already been executed. When the specified number&#160;is&#160;<br/>exceeded, the Flash Boot Loader rejects&#160;another flash&#160;request.<br/>
A RAM (Random Access Memory) requires a permanent power supply; otherwise it loses its con-<br/>tents. While flash memory serves the purpose of long-term storage of the application, the RAM&#160;<br/>is used to buffer computed data and other temporary information. Shutting off the power sup-<br/>ply causes the RAM contents to be lost. In contrast to flash memory, it is easy to read and write&#160;<br/>to RAM.&#160;<br/>
<hr/>
<a name=17></a>1 Fundamentals of the XCP Protocol<br/>
17<br/>
This fact is clear: if parameters need to be changed at runtime, it must be assured that they are&#160;<br/>located&#160;in&#160;RAM.&#160;It&#160;is&#160;really&#160;very&#160;important&#160;to understand this&#160;circumstance.&#160;That&#160;is&#160;why&#160;we&#160;will&#160;<br/>look at the execution of an&#160;application in the ECU based on the following example:&#160;<br/>
In the application,&#160;the y&#160;parameters are computed from the sensor&#160;values x.&#160;<br/>
// Pseudo-code&#160;representation<br/>a = 5;<br/>b = 2;<br/>y = a * x + b;<br/>
If&#160;the&#160;application&#160;is&#160;flashed&#160;in&#160;the&#160;ECU,&#160;the&#160;controller&#160;handles&#160;this&#160;code&#160;as&#160;follows&#160;after&#160;booting:&#160;<br/>the values of the x parameters correspond to a sensor value. At some time point, the application&#160;<br/>must therefore poll the sensor value and the value is then stored in a memory location assigned&#160;<br/>to the x parameters. Since this value always needs to be rewritten at runtime, the memory loca-<br/>tion can only lie in RAM.&#160;<br/>
The parameter y is computed. The values a and b, as factor and offset, are included as informa-<br/>tion in flash memory. They are stored as constants there. The value of y must also be stored in&#160;<br/>RAM, because once again that is the only place where write access is possible. At precisely which&#160;<br/>location in RAM the parameters x and y are located, or where a and b lie in flash, is set in the&#160;<br/>compiler/linker run. This is where objects are allocated to unique addresses. The relationship&#160;<br/>between object&#160;name, data type&#160;and address is documented in the linker-map file.&#160;The linker-<br/>map file is generated by the Linker run and can exist in different formats. Common to all for-<br/>mats,&#160;however, is that they contain the object&#160;name and address&#160;at a minimum.&#160;<br/>
In the example, if the offset b and factor a depend on the specific vehicle, the values of a and b&#160;<br/>must be individually adapted to the specific conditions of the vehicle. This means that the algo-<br/>rithm&#160;remains as it is,&#160;but the parameter values change&#160;from vehicle to vehicle.<br/>
In the normal operating mode of an ECU, the application runs from the flash memory. It does&#160;<br/>not permit any write accesses to individual objects. This means that parameter values which are&#160;<br/>located&#160;in&#160;the&#160;flash&#160;area&#160;cannot&#160;be&#160;modified&#160;at&#160;runtime.&#160;If&#160;a&#160;change&#160;to&#160;parameter&#160;values&#160;should&#160;<br/>be possible during runtime, the parameters to be modified must lie in RAM and not in flash.&#160;<br/>Now,&#160;how&#160;do&#160;the&#160;parameters&#160;and&#160;their&#160;initial&#160;values&#160;make&#160;their&#160;way into&#160;RAM?&#160;How&#160;does&#160;one&#160;<br/>solve the problem of needing to modify more parameters than can be simultaneously stored in&#160;<br/>RAM? These issues&#160;lead us to the topic of calibration concepts&#160;(see chapter 3).<br/>
<hr/>
<a name=18></a>18<br/>
1 Fundamentals of the XCP Protocol<br/>
<b>Summary&#160;of XCP fundamentals</b><br/>
Read and write accesses to memory contents are available with the mechanisms of the XCP pro-<br/>tocol. The accesses are made in an address-oriented way. Read access enables measurement of&#160;<br/>parameters from RAM, and write access enables calibration of the parameters in RAM. XCP per-<br/>mits execution of the measurement synchronous to events in the ECU. This ensures that the&#160;<br/>measured&#160;values&#160;correlate&#160;with&#160;one&#160;another.&#160;With&#160;every&#160;restart&#160;of&#160;a&#160;measurement,&#160;the&#160;signals&#160;<br/>to be measured can be freely selected. For write access, the parameters to be calibrated must be&#160;<br/>stored in RAM. This requires a calibration concept.<br/>
This leads to two important&#160;questions:<br/>&gt;&#160;&#160;How does the user of the XCP protocol know the correct addresses of the measurement and&#160;<br/>
calibration&#160;parameters in RAM?<br/>
&gt;&#160;&#160;What does the&#160;calibration concept look like?<br/>
The&#160;first&#160;question is&#160;answered in&#160;chapter&#160;2&#160;“ECUs&#160;description&#160;file&#160;A2L”.&#160;The&#160;topic&#160;of&#160;the&#160;calibra-<br/>tion concept is addressed in chapter 3.<br/>
<hr/>
<a name=19></a>1.1 XCP Protocol Layer<br/>
19<br/>
<b>1.1 XCP Protocol Layer</b><br/>
XCP data is exchanged between the Master and Slave in a message-based way. The entire “XCP&#160;<br/>message frame” is embedded in a frame of the transport layer (in the case of XCP on Ethernet&#160;<br/>with UDP in a UDP packet). The frame consists of three parts: the XCP header, the XCP packet&#160;<br/>and the XCP&#160;tail.&#160;<br/>
In the following figure, part of a message is shown in red. It is used to send the current XCP&#160;<br/>frame.&#160;The XCP header and XCP tail&#160;depend on the transport protocol.<br/>
XCP Message (Frame)<br/>
XCP Header<br/>
<b>XCP Packet</b><br/>
XCP Tail<br/>
<b>PID&#160;FILL</b><br/>
<b>DAQ</b><br/>
<b>TIMESTAMP</b><br/>
<b>DATA</b><br/>
<b>Identification</b><br/>
<b>Timestamp</b><br/>
<b>Data&#160;</b><br/>
<b>Field</b><br/>
<b>Field</b><br/>
<b>Field</b><br/>
<b>Figure 6: XCP packet</b><br/>
The XCP packet itself is independent of the transport protocol used. It always contains three&#160;<br/>components:&#160;“Identification&#160;Field”,&#160;“Timestamp Field”&#160;and the current&#160;data field&#160;“Data Field”.&#160;<br/>Each Identification Field&#160;begins with the Packet Identifier (PID), which identifies&#160;the packet.&#160;<br/>
The following overview shows which PIDs have been defined:<br/>
PID for frames&#160;<br/>
PID for frames&#160;<br/>
from Master to Slave<br/>
from Slave to Master<br/>
0xFF<br/>
0xFF<br/>
RES<br/>
0xFE<br/>
ERR<br/>
CMD<br/>
....<br/>
0xFD<br/>
EV<br/>
0xC0<br/>
0xFC<br/>
SERV<br/>
0xBF<br/>
0xFB<br/>
absolute or&#160;<br/>
absolute or&#160;<br/>
relative&#160;<br/>
relative&#160;<br/>
....<br/>
ODT number&#160;<br/>
....<br/>
ODT number&#160;<br/>
for STIM<br/>
for STIM<br/>
0x00<br/>
0x00<br/>
<b>Figure 7: Overview of&#160;XCP Packet Identifier (PID)</b><br/>
<hr/>
<a name=20></a>20<br/>
1 Fundamentals of the XCP protocol<br/>
Communication&#160;via the XCP packet is subdivided into one area for commands (CTO) and one area&#160;<br/>for sending synchronous data (DTO).&#160;<br/>
<b>XCP Master</b><br/>
XCP Driver<br/>
CTO<br/>
DTO<br/>
CMD<br/>
RES<br/>
ERR<br/>
EV<br/>
SERV<br/>
DAQ<br/>
STIM<br/>
Command / Response / Error / Event&#160;/<br/>
DAQ<br/>
STIM<br/>
Service Request Processor&#160;<br/>
Processor<br/>
Processor<br/>
Bypass<br/>
XCP Handler<br/>
PGM<br/>
CAL<br/>
DAQ<br/>
STIM<br/>
Resources<br/>
<b>Figure 8:&#160;</b><br/>
<b>XCP Slave</b><br/>
<b>XCP communication&#160;<br/>model with CTO/DTO</b><br/>
The acronyms&#160;used here stand for<br/>
CMD&#160;<br/>
Command Packet&#160;&#160;<br/>
sends commands&#160;<br/>
RES&#160;<br/>
Command Response&#160;Packet&#160;<br/>
positive&#160;response<br/>
ERR&#160;<br/>
Error&#160;<br/>
negative response<br/>
EV&#160;<br/>
Event Packet&#160;<br/>
asynchronous&#160;event<br/>
SERV&#160;&#160;<br/>
Service&#160;Request Packet&#160;<br/>
service&#160;request<br/>
DAQ&#160;<br/>
Data AcQuisition&#160;<br/>
send periodic measured values<br/>
STIM&#160;<br/>
Stimulation&#160;<br/>
periodic&#160;stimulation&#160;of the Slave<br/>
Commands are exchanged via CTOs (Command Transfer Objects). The Master initiates contact in&#160;<br/>this way, for example. The Slave must always respond to a CMD with RES or ERR. The other CTO&#160;<br/>messages are sent asynchronously. The Data Transfer Objects (DTO) are used to exchange syn-<br/>chronous&#160;measurement and stimulation&#160;data.&#160;<br/>
<hr/>
<a name=21></a>1.1 XCP Protocol Layer<br/>
21<br/>
<b>1.1.1&#160;Identification&#160;Field</b><br/>
XCP Packet<br/>
<b>PID&#160;FILL&#160;DAQ</b><br/>
TIMESTAMP<br/>
DATA<br/>
<b>Figure 9:&#160;&#160;</b><br/>
<b>Identification Field</b><br/>
<b>Message&#160;<br/>identification</b><br/>
When messages are exchanged, both the Master and Slave must be able to determine which&#160;<br/>message was sent by the other. This is accomplished in the identification field. That is why each&#160;<br/>message begins&#160;with the Packet Identifier&#160;(PID).<br/>
In transmitting CTOs, the PID field is fully sufficient to identify a CMD, RES or other CTO packet.&#160;<br/>In Figure 7, it can be seen that commands from the Master to the Slave utilize a PID from 0xC0 to&#160;<br/>0xFF. The XCP Slave responds or informs the Master with PIDs from 0xFC to 0xFF. This results in a&#160;<br/>unique allocation&#160;of the PIDs to the individually sent CTOs.<br/>When DTOs are transmitted, other elements of the identification field are used (see chapter&#160;<br/>1.3.4 “XCP Packet Addressing for&#160;DAQ&#160;and STIM”).<br/>
<b>1.1.2&#160;Time Stamp</b><br/>
XCP Packet<br/>
PID&#160;FILL&#160;DAQ<br/>
<b>TIMESTAMP</b><br/>
DATA<br/>
<b>Figure 10:<br/>Time stamp</b><br/>
DTO&#160;packets use time stamps, but this is not possible in transmission of a CTO message. The&#160;<br/>Slave uses the time stamp to supply time information with measured values. That is, the Mas-<br/>ter not only has the measured value, but also the time point at which the measured value was&#160;<br/>acquired. The amount of time it takes for the measured value to arrive at the Master is no lon-<br/>ger important, because the relationship between the measured value and the time point comes&#160;<br/>directly&#160;from the Slave.&#160;<br/>Transmission of a time stamp from the Slave is optional. This topic is discussed further in&#160;&#160;<br/>ASAM&#160;XCP Part 2 Protocol Layer Specification.&#160;<br/>
<hr/>
<a name=22></a>22<br/>
1 Fundamentals of the XCP protocol<br/>
<b>1.1.3&#160;Data Field&#160;</b><br/>
XCP Packet<br/>
PID&#160;FILL&#160;DAQ<br/>
TIMESTAMP<br/>
<b>DATA</b><br/>
<b>Figure 11:&#160;<br/>Data field&#160;&#160;</b><br/>
<b>Data Field</b><br/>
<b>in the XCP packet</b><br/>
Finally, the XCP packet also&#160;contains the data stored in the data&#160;field. In the case of&#160;CTO&#160;<br/>packets, the data field consists of specific parameters for the different commands. DTO&#160;<br/>packets contain the measured values from the Slave and when STIM data is sent the values from&#160;<br/>the Master.<br/>
<b>1.2 Exchange of CTOs&#160;</b><br/>
CTOs are used to transmit both commands from the Master to the Slave and responses from the&#160;<br/>Slave to the Master.&#160;<br/>
<b>1.2.1&#160;XCP Command Structure</b><br/>
The&#160;Slave receives a&#160;command&#160;from&#160;the&#160;Master and&#160;must&#160;react&#160;to&#160;it with&#160;a positive or&#160;negative&#160;<br/>response. The communication&#160;structure is always the same here:<br/>
Command (CMD):<br/>
<b>Position&#160;</b><br/>
<b>Type&#160;Description</b><br/>
0&#160;<br/>
BYTE&#160;<br/>
Command Packet Code CMD<br/>
1..MAX_CTO-1&#160;<br/>
BYTE&#160;<br/>
Command specific Parameters<br/>
A unique number is assigned to each command. In addition, other specific parameters may be&#160;<br/>sent with the command. The maximum number of parameters is defined as MAX_CTO-1 here.&#160;<br/>MAX_CTO indicates the maximum&#160;length&#160;of the CTO packets&#160;in bytes.&#160;<br/>
Positive&#160;response:<br/>
<b>Position&#160;&#160;Type&#160;Description<br/></b>0&#160;<br/>
BYTE&#160;<br/>
Command Positive Response Packet Code = RES 0xFF<br/>
1..MAX_CTO-1&#160;<br/>
BYTE&#160;<br/>
Command specific Parameters&#160;<br/>
<hr/>
<a name=23></a>1.2 Exchange of CTOs&#160;<br/>
23<br/>
Negative&#160;response:<br/>
<b>Position&#160;</b><br/>
<b>Type&#160;Description</b><br/>
0&#160;<br/>
BYTE&#160;<br/>
Error Packet Code = 0xFE<br/>
1&#160;<br/>
BYTE&#160;<br/>
Error code<br/>
2..MAX_CTO-1&#160;<br/>
BYTE&#160;<br/>
Command specific Parameters<br/>
Specific parameters can be transmitted as supplemental information with negative responses as&#160;<br/>well&#160;and&#160;not&#160;just&#160;with&#160;positive&#160;responses.&#160;One&#160;example&#160;is&#160;when&#160;the&#160;connection&#160;is&#160;made&#160;between&#160;<br/>Master and Slave. At the start of a communication between Master and Slave, the Master sends&#160;<br/>a connect request to the Slave, which in turn must respond positively to produce a continuous&#160;<br/>point-to-point&#160;connection.<br/>
Master&#160;à&#160;Slave: Connect&#160;<br/>Slave&#160;à&#160;Master: Positive response&#160;<br/>
Connect command:<br/>
<b>Position&#160;&#160;Type&#160;Description<br/></b>0&#160;<br/>
BYTE&#160;<br/>
Command Code = 0xFF<br/>
1&#160;<br/>
BYTE&#160;Mode&#160;<br/>
&#160;<br/>
&#160;<br/>
00 = Normal<br/>
&#160;<br/>
&#160;<br/>
01 = user defined<br/>
Mode&#160;00&#160;means&#160;that&#160;the&#160;Master&#160;wishes&#160;XCP&#160;communication&#160;with&#160;the&#160;Slave.&#160;If&#160;the&#160;Master&#160;uses&#160;<br/>0xFF 0x01 when making the connection, the Master is requesting XCP communication with the&#160;<br/>Slave. Simultaneously, it informs the Slave that it should switch to a specific – user-defined&#160;<br/>– mode.&#160;<br/>
Positive&#160;response of the Slave:<br/>
<b>Position&#160;&#160;Type&#160;Description<br/></b>0&#160;<br/>
BYTE&#160;<br/>
Packet ID: 0xFF<br/>
1&#160;<br/>
BYTE&#160;RESOURCE<br/>
2&#160;<br/>
BYTE&#160;COMM_MODE_BASIC<br/>
3&#160;<br/>
BYTE&#160;<br/>
MAX_CTO, Maximum&#160;CTO size [BYTE]<br/>
4&#160;<br/>
WORD&#160;<br/>
MAX_DTO, Maximum&#160;DTO size [BYTE]<br/>
6&#160;<br/>
BYTE&#160;<br/>
XCP Protocol&#160;Layer Version Number&#160;(most significant byte only)<br/>
7&#160;<br/>
BYTE&#160;<br/>
XCP Transport&#160;Layer Version Number&#160;(most significant byte only)<br/>
The positive response of&#160;the Slave can&#160;assume a somewhat more extensive form.&#160;The Slave&#160;<br/>already sends communication-specific information to the Master when making the connection.&#160;<br/>RESOURCE, for example, is information that the Slave gives on whether it supports such features&#160;<br/>as page switching or whether flashing over XCP is possible. With MAX_DTO, the Slave informs the&#160;<br/>Master of the maximum packet length it supports for transfer of the measured values, etc. You&#160;<br/>will&#160;find details on the parameters&#160;in ASAM XCP Part&#160;2 Protocol Layer&#160;Specification.<br/>
<hr/>
<a name=24></a>24<br/>
1 Fundamentals of the XCP protocol<br/>
XCP&#160;permits&#160;three different&#160;modes&#160;for&#160;exchanging&#160;commands&#160;and&#160;reactions&#160;between&#160;Master&#160;and&#160;<br/>Slave: Standard, Block and Interleaved&#160;mode.<br/>
<b>Standard Mode</b><br/>
<b>Block Mode</b><br/>
<b>Interleaved Mode</b><br/>
Master<br/>
Slave&#160;Master<br/>
Slave<br/>
Master<br/>
Slave<br/>
Request&#160;k<br/>
Request&#160;k<br/>
Part1<br/>
Request&#160;k<br/>
Part2<br/>
MIN_ST<br/>
Part3<br/>
Request k+1<br/>
Response&#160;k<br/>
MAX_BS<br/>
Response&#160;k<br/>
Request k+1<br/>
Response&#160;k<br/>
Request k+1<br/>
Response k+1<br/>
Response k+1<br/>
Part1<br/>
Response k+1<br/>
Part2<br/>
Part3<br/>
Time<br/>
Time<br/>
Time<br/>
<b>Figure 12: The three modes of the XCP protocol: Standard, Block and Interleaved mode</b><br/>
In the standard communication model, each request to a Slave is followed by a single response.&#160;<br/>Except&#160;with XCP&#160;on CAN, it is&#160;not permitted&#160;for multiple&#160;Slaves&#160;to react&#160;to a&#160;command from the&#160;<br/>Master. Therefore, each XCP message can always be traced back to a unique Slave. This mode is&#160;<br/>the standard case in communication.<br/>
The block transfer mode is optional and saves time in large data transfers (e.g. upload or&#160;<br/>download operations). Nonetheless, performance issues must be considered in this mode&#160;<br/>in the direction of the Slave. Therefore, minimum times between two commands (MIN_ST)&#160;<br/>must be maintained and the total number of commands must be limited to an upper limit&#160;&#160;<br/>MAX_BS. Optionally, the Master can read out these communication settings from the Slave with&#160;&#160;<br/>GET_COMM_MODE_INFO. The aforementioned limitations do not need to be observed in block&#160;<br/>transfer mode in the direction of the Master, because performance of the PC nearly always suf-<br/>fices to accept the data&#160;from a microcontroller.<br/>
The interleaved mode is also provided for performance reasons. But this method is also optional&#160;<br/>and – in contrast to block&#160;transfer mode&#160;– it has no relevance&#160;in practice.&#160;<br/>
<hr/>
<a name=25></a>1.2 Exchange of CTOs&#160;<br/>
25<br/>
<b>1.2.2&#160;CMD&#160;</b><br/>
<b>XCP CTO Packet</b><br/>
PID<br/>
DATA<br/>
Data Field<br/>
Identification Field<br/>
Timestamp Field<br/>empty for CTO<br/>
<b>Figure 13: Overview of the CTO packet structure</b><br/>
The Master sends a general request to the Slave over CMD. The PID (Packet Identifier) field&#160;<br/>contains the identification number of the command. The additional specific parameters are&#160;<br/>transported in the data field. Then the Master waits for a reaction of the Slave in the form of a&#160;<br/>RESponse or an ERRor.<br/>
XCP is also very scalable in its implementation, so it is not necessary to implement every com-<br/>mand. In the A2L file, the available CMDs are listed in what is known as the XCP IF_DATA. If there&#160;<br/>is a discrepancy between the definition in the A2L file and the implementation in the Slave, the&#160;<br/>Master can determine, based on the Slave’s reaction, that the Slave does&#160;not even&#160;support the&#160;<br/>command. If the Master sends a command that is not implemented in the Slave, the Slave must&#160;<br/>acknowledge with ERR_CMD_UNKNOWN and no further activities are initiated in the Slave. This&#160;<br/>lets the Master know quickly that an optional command has not been implemented in the Slave.&#160;<br/>Some other parameters are included in the commands as well. Please take the precise details&#160;<br/>from the protocol layer specification in&#160;document ASAM XCP&#160;Part 2.&#160;<br/>&#160;<br/>The commands are organized in groups: Standard, Calibration, Page, Programming and DAQ&#160;<br/>measurement commands. If a group is not needed at all, its commands do not need to be imple-<br/>mented. If the group is necessary, certain commands must always be available in the Slave,&#160;<br/>while others from the group&#160;are optional.<br/>
The&#160;following&#160;overview&#160;serves&#160;as&#160;an&#160;example.&#160;The&#160;SET_CAL_PAGE&#160;and&#160;GET_CAL_PAGE&#160;commands&#160;<br/>in the Page-Switching group are identified as not optional. This means that in an XCP Slave that&#160;<br/>supports Page Switching at least these two commands must be implemented. If Page-Switching&#160;<br/>support is unnecessary in the Slave, these commands do not need to be implemented. The same&#160;<br/>applies to other commands.<br/>
<hr/>
<a name=26></a>26<br/>
1 Fundamentals of the XCP protocol<br/>
Standard commands:<br/>
<b>Command&#160;&#160;PID&#160;Optional<br/></b>CONNECT&#160;&#160;0xFF&#160;No<br/>DISCONNECT&#160;0xFE&#160;&#160;No<br/>GET_STATUS&#160;0xFD&#160;No<br/>SYNCH&#160;<br/>
0xFC&#160;No<br/>
GET_COMM_MODE_INFO&#160;0xFB&#160;<br/>
Yes<br/>
GET_ID&#160;<br/>
0xFA&#160;Yes<br/>
SET_REQUEST&#160;0xF9&#160;&#160;Yes<br/>GET_SEED&#160;&#160;0xF8&#160;Yes<br/>UNLOCK&#160;<br/>
0xF7&#160;Yes<br/>
SET_MTA&#160;<br/>
0xF6&#160;Yes<br/>
UPLOAD&#160;<br/>
0xF5&#160;Yes<br/>
SHORT_UPLOAD&#160;0xF4&#160;<br/>
Yes<br/>
BUILD_CHECKSUM&#160;0xF3&#160;<br/>
Yes<br/>
TRANSPORT_LAYER_CMD&#160;0xF2&#160;<br/>
Yes<br/>
USER_CMD&#160;&#160;0xF1&#160;Yes<br/>
Calibration&#160;commands:<br/>
<b>Command&#160;&#160;PID&#160;Optional<br/></b>DOWNLOAD&#160;&#160;0xF0&#160;No<br/>DOWNLOAD_NEXT&#160;0xEF&#160;<br/>
Yes<br/>
DOWNLOAD_MAX&#160;0xEE&#160;<br/>
Yes<br/>
SHORT_DOWNLOAD&#160;0xED&#160;<br/>
Yes<br/>
MODIFY_BITS&#160;0xEC&#160;&#160;Yes<br/>
Standard commands:<br/>
<b>Command&#160;&#160;PID&#160;Optional<br/></b>SET_CAL_PAGE&#160;0xEB&#160;&#160;No<br/>GET_CAL_PAGE&#160;0xEA&#160;&#160;No<br/>GET_PAG_PROCESSOR_INFO&#160;0xE9&#160;<br/>
Yes<br/>
GET_SEGMENT_INFO&#160;0xE8&#160;<br/>
Yes<br/>
GET_PAGE_INFO&#160;0xE7&#160;<br/>
Yes<br/>
SET_SEGMENT_MODE&#160;0xE6&#160;<br/>
Yes<br/>
GET_SEGMENT_MODE&#160;0xE5&#160;<br/>
Yes<br/>
COPY_CAL_PAGE&#160;0xE4&#160;<br/>
Yes<br/>
<hr/>
<a name=27></a>1.2 Exchange of CTOs&#160;<br/>
27<br/>
Periodic&#160;data exchange – basics:<br/>
<b>Command&#160;&#160;PID&#160;Optional<br/></b>SET_DAQ_PTR&#160;0xE2&#160;&#160;No<br/>WRITE_DAQ&#160;&#160;0xE1&#160;No<br/>SET_DAQ_LIST_MODE&#160;0xE0&#160;<br/>
No<br/>
START_STOP_DAQ_LIST&#160;0xDE&#160;<br/>
No<br/>
START_STOP_SYNCH&#160;0xDD&#160;<br/>
No<br/>
WRITE_DAQ_MULTIPLE&#160;0xC7&#160;<br/>
Yes<br/>
READ_DAQ&#160;&#160;0xDB&#160;Yes<br/>GET_DAQ_CLOCK&#160;0xDC&#160;<br/>
Yes<br/>
GET_DAQ_PROCESSOR_INFO&#160;0xDA&#160;<br/>
Yes<br/>
GET_DAQ_RESOLUTION_INFO&#160;0xD9&#160;<br/>
Yes<br/>
GET_DAQ_LIST_INFO&#160;0xD8&#160;<br/>
Yes<br/>
GET_DAQ_EVENT_INFO&#160;0xD7&#160;<br/>
Yes<br/>
Periodic&#160;data exchange – static&#160;configuration:&#160;<br/>
<b>Command&#160;&#160;PID&#160;Optional<br/></b>CLEAR_DAQ_LIST&#160;0xE3&#160;<br/>
No<br/>
GET_DAQ_LIST_INFO&#160;0xD8&#160;<br/>
Yes<br/>
Periodic&#160;data exchange – dynamic&#160;configuration:&#160;<br/>
<b>Command&#160;&#160;PID&#160;Optional<br/></b>FREE_DAQ&#160;&#160;0xD6&#160;Yes<br/>ALLOC_DAQ&#160;&#160;0xD5&#160;Yes<br/>ALLOC_ODT&#160;&#160;0xD4&#160;Yes<br/>ALLOC_ODT_ENTRY&#160;0xD3&#160;<br/>
Yes<br/>
<hr/>
<a name=28></a>28<br/>
1 Fundamentals of the XCP protocol<br/>
Flash programming:<br/>
<b>Command&#160;&#160;PID&#160;Optional<br/></b>PROGRAM_START&#160;0xD2&#160;<br/>
No<br/>
PROGRAM_CLEAR&#160;0xD1&#160;<br/>
No<br/>
PROGRAM&#160;&#160;0xD0&#160;No<br/>PROGRAM_RESET&#160;0xCF&#160;<br/>
No<br/>
GET_PGM_PROCESSOR_INFO&#160;0xCE&#160;<br/>
Yes<br/>
GET_SECTOR_INFO&#160;0xCD&#160;<br/>
Yes<br/>
PROGRAM_PREPARE&#160;0xCC&#160;<br/>
Yes<br/>
PROGRAM_FORMAT&#160;0xCB&#160;<br/>
Yes<br/>
PROGRAM_NEXT&#160;0xCA&#160;<br/>
Yes<br/>
PROGRAM_MAX&#160;0xC9&#160;<br/>
Yes<br/>
PROGRAM_VERIFY&#160;0xC8&#160;<br/>
Yes<br/>
<b>1.2.3&#160;RES&#160;</b><br/>
If the Slave is able to successfully comply with a Master’s request, it gives a positive acknowl-<br/>edge with RES.&#160;<br/>
<b>Position&#160;</b><br/>
<b>Type&#160;Description</b><br/>
0&#160;<br/>
BYTE&#160;<br/>
Packet Identifier = RES 0xFF<br/>
1..MAX_CTO-1&#160;<br/>
BYTE&#160;<br/>
Command response&#160;data<br/>
You will find more detailed information on the parameters in ASAM XCP Part 2 Protocol Layer&#160;<br/>Specification.<br/>
<b>1.2.4&#160;ERR&#160;</b><br/>
If the request from the Master is unusable, it responds with the error message ERR and an error&#160;<br/>code.&#160;<br/>
<b>Position&#160;</b><br/>
<b>Type&#160;Description</b><br/>
0&#160;<br/>
BYTE&#160;<br/>
Packet Identifier = ERR 0xFE<br/>
1&#160;<br/>
BYTE&#160;<br/>
Error code<br/>
2..MAX_CTO-1&#160;<br/>
BYTE&#160;<br/>
Optional&#160;error information&#160;data<br/>
You will&#160;find a list of&#160;possible error codes in&#160;ASAM XCP Part&#160;2 Protocol Layer Specification.<br/>
<hr/>
<a name=29></a>1.2 Exchange of CTOs&#160;<br/>
29<br/>
<b>1.2.5&#160;EV&#160;</b><br/>
If&#160;the&#160;Slave&#160;wishes&#160;to&#160;inform&#160;the&#160;Master&#160;of&#160;an&#160;asynchronous&#160;event,&#160;an&#160;EV&#160;can&#160;be&#160;sent&#160;to&#160;do&#160;this.&#160;<br/>Its implementation is optional.<br/>
<b>Position&#160;</b><br/>
<b>Type&#160;Description</b><br/>
0&#160;<br/>
BYTE&#160;<br/>
Packet Identifier = EV 0xFD<br/>
1&#160;<br/>
BYTE&#160;<br/>
Event code<br/>
2..MAX_CTO-1&#160;<br/>
BYTE&#160;<br/>
Optional&#160;event&#160;information&#160;data<br/>
You will find more detailed information on the parameters in ASAM XCP Part 2 Protocol Layer&#160;<br/>Specification.<br/>
Events&#160;will&#160;be&#160;discussed&#160;much&#160;more&#160;in&#160;relation&#160;to&#160;measurements&#160;and&#160;stimulation.&#160;This&#160;has&#160;noth-<br/>ing&#160;to&#160;do&#160;with&#160;the&#160;action&#160;of&#160;the&#160;XCP&#160;Slave&#160;that&#160;initiates&#160;sending&#160;of&#160;an&#160;EVENT.&#160;Rather&#160;it&#160;involves&#160;<br/>the Slave reporting a disturbance such as the failure of a specific&#160;functionality.<br/>
<b>1.2.6&#160;SERV&#160;</b><br/>
The Slave can use this mechanism&#160;to request that the Master execute a service.&#160;<br/>
<b>Position&#160;&#160;Type&#160;Description<br/></b>0&#160;<br/>
BYTE&#160;<br/>
Packet Identifier = SERV 0xFC<br/>
1&#160;<br/>
BYTE&#160;<br/>
Service&#160;request code<br/>
2..MAX_CTO-1&#160;<br/>
BYTE&#160;<br/>
Optional&#160;service request data<br/>
You will find the Service Request Code table in ASAM XCP Part 2 Protocol Layer Specification.&#160;<br/>
<b>1.2.7&#160;Calibrating Parameters in the Slave</b><br/>
To&#160;change&#160;a&#160;parameter&#160;in&#160;an&#160;XCP&#160;Slave,&#160;the&#160;XCP&#160;Master&#160;must&#160;send&#160;the&#160;parameter’s&#160;location&#160;as&#160;<br/>well as the value itself&#160;to the Slave.<br/>XCP always defines addresses with five bytes: four for the actual address and one byte for the&#160;<br/>address&#160;extension. Based&#160;on&#160;a&#160;CAN&#160;transmission,&#160;only&#160;seven&#160;useful&#160;bytes&#160;are&#160;available&#160;for&#160;XCP&#160;<br/>messages. For example, if the calibrator sets a 4-byte value and wants to send both pieces of&#160;<br/>information in one CAN message, there is insufficient space to do this. Since a total of nine&#160;<br/>bytes are needed to transmit the address and the new value, the change cannot be transmit-<br/>ted&#160;in&#160;one&#160;CAN&#160;message&#160;(seven&#160;useful&#160;bytes).&#160;The&#160;calibration&#160;request&#160;is&#160;therefore&#160;made&#160;with&#160;<br/>two messages from Master to Slave. The Slave must acknowledge both messages and in sum four&#160;<br/>messages are exchanged.<br/>
<hr/>
<a name=30></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-30_1.png"/><br/>
30<br/>
1 Fundamentals of the XCP protocol<br/>
The following figure shows the communication between Master and Slave, which is necessary to&#160;<br/>set a parameter value. The actual message is located in the line with the envelope symbol. The&#160;<br/>interpretation&#160;of the message is shown by “expanding”&#160;it with&#160;the mouse.&#160;<br/>
<b>Figure 14: Trace example from a calibration process</b><br/>
In the first message of the Master (highlighted in gray in Figure 14), the Master sends the&#160;&#160;<br/>command&#160;SET_MTA&#160;to&#160;the&#160;Slave&#160;with&#160;the&#160;address&#160;to&#160;which&#160;a&#160;new&#160;value&#160;should&#160;be&#160;written.&#160;In&#160;<br/>the second&#160;message, the Slave gives&#160;a positive acknowledge to the command&#160;with Ok:SET_MTA.<br/>
The third message DOWNLOAD transmits the hex value as well as the valid number of bytes.&#160;<br/>In this example, the valid number of bytes is four, because it is a float value. The Slave gives&#160;<br/>another&#160;positive acknowledge&#160;in the fourth&#160;message.<br/>
This completes the current calibration process. In the Trace display, you can recognize a termi-<br/>nating SHORT_UPLOAD – a special aspect of CANape, the measurement and calibration tool from&#160;<br/>Vector. To make sure that the calibration was performed successfully, the value is read out again&#160;<br/>after&#160;the&#160;process&#160;and&#160;the&#160;display&#160;is&#160;updated&#160;with&#160;the&#160;read-out&#160;value.&#160;This&#160;lets&#160;the&#160;user&#160;directly&#160;<br/>recognize whether the calibration command was implemented. This command also gets a posi-<br/>tive acknowledge with Ok:SHORT_UPLOAD.&#160;<br/>
When&#160;the&#160;parameter&#160;changes&#160;in&#160;the&#160;ECU’s&#160;RAM,&#160;the&#160;application&#160;processes&#160;the&#160;new&#160;value.&#160;A&#160;<br/>reboot&#160;of the ECU,&#160;however,&#160;would&#160;lead&#160;to erasure of&#160;the&#160;value&#160;and overwriting&#160;of the&#160;value&#160;in&#160;<br/>RAM with the original value from the flash (see chapter 3 “Calibration Concepts”). So, how can&#160;<br/>the modified parameter&#160;set be permanently saved?<br/>
<hr/>
<a name=31></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-31_1.png"/><br/>
1.2 Exchange of CTOs&#160;<br/>
31<br/>
Essentially, there are two possibilities:&#160;<br/>
<b>A) Save&#160;the parameters in&#160;the ECU<br/></b>The changed data in RAM could for example be saved in the ECU’s EEPROM: either automatically&#160;<br/>when ramping down the ECU, or manually by the user. A prerequisite is that the data can be&#160;<br/>stored in a nonvolatile memory of the Slave. In an ECU, this would be the EEPROM or flash. ECUs&#160;<br/>with thousands of parameters, however, are seldom able to provide so much unused EEPROM&#160;<br/>memory space, so this method is rare.<br/>
Another possibility is to write the RAM parameters back into the ECU’s flash memory. This&#160;<br/>method&#160;is&#160;relatively&#160;complex.&#160;A&#160;flash&#160;memory&#160;must&#160;first&#160;be&#160;erased&#160;before&#160;it&#160;can&#160;be&#160;rewritten.&#160;<br/>This, in turn, can only be done as a block. Consequently, it is not simply a matter of writing back&#160;<br/>individual&#160;bytes. You will&#160;find more on this&#160;topic in chapter 3 “Calibration&#160;Concepts”.&#160;<br/>
<b>B) Save&#160;the parameters in&#160;the form of a file on the PC<br/></b>It is much more common to store the parameters on the PC. All parameters – or subsets of them&#160;<br/>– are stored in the form of a file. Different formats are available for this; the simplest case is&#160;<br/>that&#160;of an ASCII&#160;text&#160;file,&#160;which only&#160;contains&#160;the name&#160;of the&#160;object and&#160;its value.&#160;Other&#160;for-<br/>mats also permit saving other information, such as findings about the maturity level of the&#160;<br/>parameter of the history of revisions.&#160;<br/>
Scenario: After finishing his or her work, the calibrator wishes to enjoy a free evening. So, the&#160;<br/>calibrator saves the executed changes in the ECU’s RAM in the form of a parameter set file on a&#160;<br/>PC. The next day, the calibrator wants to continue working where he or she left off. The calibra-<br/>tor starts the ECU. Upon booting, the parameters are initialized in RAM. However, the ECU does&#160;<br/>this using values stored in flash. This means that the changes of the previous day are no longer&#160;<br/>available in the ECU. To now continue where work was left off on the previous day, the calibra-<br/>tor transfers the contents of the parameter set file to the ECU’s RAM by XCP using the DOWNLOAD&#160;<br/>command.<br/>
<b>Figure 15: Transfer of a parameter set file to an ECU’s RAM</b><br/>
<hr/>
<a name=32></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-32_1.png"/><br/>
32<br/>
1 Fundamentals of the XCP protocol<br/>
<b>Saving&#160;parameter set file in hex&#160;files and flashing</b><br/>
Flashing an ECU is another way to change the parameters in flash. They are then written to RAM&#160;<br/>as&#160;new parameters&#160;when the ECU&#160;is&#160;booted. A&#160;parameter set&#160;file&#160;can&#160;also be&#160;transferred to&#160;a C&#160;or&#160;<br/>H file and be made into the new flash file with another compiler/linker run. However, depend-<br/>ing on the parameters of the code, the process of generating a flashable hex file could take a&#160;<br/>considerable amount of time. In addition, the calibrator might not have any ECU source code&#160;<br/>– depending on the work process. That would prevent this method from being available to the&#160;<br/>calibrator.&#160;<br/>
As an alternative, the calibrator can copy&#160;the parameter set file into the existing&#160;flash file.&#160;<br/>
<b>Figure 16: Hex window</b><br/>
In the flash file, there is a hex file that contains both the addresses and the values. Now a&#160;<br/>parameter&#160;file&#160;can&#160;be&#160;copied&#160;to&#160;a&#160;hex&#160;file.&#160;To&#160;do&#160;this,&#160;CANape&#160;takes&#160;the&#160;address&#160;and&#160;the&#160;value&#160;<br/>from the parameter set file and updates the parameter value at the relevant location in the&#160;<br/>hex file. This results in a new hex file, which contains the changed parameter values. However,&#160;<br/>this Hex file must now possibly run through further process steps to obtain a flashable file.&#160;<br/>One recurring problem here is the checksums, which the ECU checks to determine whether it&#160;<br/>received the data correctly. If the flashable file exists, it can be flashed in the ECU and after the&#160;<br/>reboot&#160;the new parameter values&#160;are available in the&#160;ECU.&#160;<br/>
<b>1.3 Exchanging&#160;DTOs&#160;– Synchronous Data Exchange&#160;</b><br/>
As depicted in Figure 8, DTOs (Data Transfer Objects) are available for exchanging synchronous&#160;<br/>measurement and calibration data. Data from the Slave are sent to the Master by DAQ – synchro-<br/>nous to internal events. This&#160;communication&#160;is subdivided into two phases:&#160;<br/>In an initialization phase, the Master communicates to the Slave which data the Slave should&#160;<br/>send for different events. After this phase, the Master initiates the measurement in the Slave&#160;<br/>and the actual measurement phase begins. From this point in time, the Slave sends the desired&#160;<br/>data to the Master, which only listens until it sends a “measurement stop” to the Slave. Trigger-<br/>ing of measurement&#160;data acquisition&#160;and transmission&#160;is controlled&#160;by events in the&#160;ECU.<br/>
<hr/>
<a name=33></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-33_1.png"/><br/>
1.3 Exchanging DTOs – Synchronous Data Exchange&#160;<br/>
33<br/>
The Master sends&#160;data to the Slave by STIM. This communication&#160;also consists of two phases:<br/>In the initialization phase, the Master communicates to the Slave which data it will send to the&#160;<br/>Slave. After this phase, the Master sends the data to the Slave and the STIM processor saves the&#160;<br/>data. As soon as a related STIM event is triggered in the Slave, the data is transferred to the&#160;<br/>application&#160;memory.&#160;<br/>
<b>1.3.1&#160;Measurement Methods: Polling versus&#160;DAQ&#160;</b><br/>
Before explaining how event-synchronous, correlated data is measured from a Slave, here is a&#160;<br/>brief description of another measurement method known as Polling. It is not based on DTOs, but&#160;<br/>on&#160;CTOs&#160;instead.&#160;Actually,&#160;this&#160;topic&#160;should&#160;be&#160;explained&#160;in&#160;a&#160;separate&#160;chapter,&#160;but&#160;a&#160;description&#160;<br/>of polling lets us derive, in a very elegant way, the necessity of DTO-based measurement, so a&#160;<br/>minor side&#160;discussion at this point makes&#160;sense.&#160;<br/>
The Master can use the SHORT_UPLOAD command to request the value of a measurement para-<br/>meter from the Slave. This is referred to as polling. This is the simplest case of a measure&#160;-<br/>ment: sending the measured value of a measurement parameter at the time at which the&#160;<br/>SHORT_UPLOAD command&#160;has been received&#160;and executed.&#160;<br/>
In the following example,&#160;the measurement&#160;parameter “Triangle” is measured&#160;from the Slave:&#160;<br/>
<b>Figure 17:&#160;<br/>Address information&#160;<br/>of the parameter&#160;<br/>“Triangle” from the&#160;<br/>A2L&#160;file</b><br/>
The address 0x60483 is expressed as an address with five bytes in the CAN frame: one byte for&#160;<br/>the address extension and four bytes for the actual&#160;address.<br/>
<hr/>
<a name=34></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-34_1.png"/><br/>
34<br/>
1 Fundamentals of the XCP protocol<br/>
<b>Figure 18: Polling communication in the CANape Trace window&#160;</b><br/>
The XCP specification sets&#160;a requirement for polling:&#160;that the&#160;value of each measurement&#160;param-<br/>eter must be polled individually. For each value to be measured via polling, two messages must&#160;<br/>go over the bus: the Master’s&#160;request to the Slave and the&#160;Slave’s response to the&#160;Master.<br/>
Besides this additional bus load, there is another disadvantage of the polling method: When&#160;<br/>polling multiple data values, the user normally wants the data to correlate to one another. How-<br/>ever,&#160;multiple&#160;values&#160;that are&#160;measured sequentially&#160;with polling do&#160;not necessarily&#160;stand in&#160;<br/>correlation&#160;to one another, i.e.&#160;they might&#160;not originate from&#160;the same ECU&#160;computing cycle.&#160;<br/>This&#160;limits&#160;the&#160;suitability&#160;of&#160;polling&#160;for&#160;measurement,&#160;because&#160;it&#160;produces&#160;unnecessarily high&#160;<br/>data traffic and the measured values are not evaluated in relation to the process flows in the&#160;<br/>ECU.&#160;<br/>
So, an optimized&#160;measurement must solve two tasks:<br/>&gt;&#160;&#160;Bandwidth optimization during the measurement<br/>&gt;&#160;&#160;Assurance&#160;of data correlation<br/>
This task is handled by the already mentioned DAQ method. DAQ stands for Data Acquisition and&#160;<br/>it is implemented by sending&#160;DTOs (Data Transfer Objects)&#160;from the&#160;Slave to the Master.<br/>
<b>1.3.2&#160;DAQ Measurement&#160;Method&#160;</b><br/>
The DAQ method&#160;solves the two problems&#160;of polling as follows:<br/>&gt;&#160;&#160;The correlation of measured values is achieved by coupling the acquisition of measured val-<br/>
ues to the events in the ECU. The measured values are not acquired and transferred until it has&#160;<br/>been assured that&#160;all computations&#160;have&#160;been completed.<br/>
&gt;&#160;&#160;To reduce bus load,&#160;the measurement process is subdivided into two phases: In a configu-<br/>
ration phase, the Master communicates which values it is interested in to the Slave and the&#160;<br/>second phase just involves transferring the measured values of the Slave to the Master.&#160;<br/>
<hr/>
<a name=35></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-35_1.png"/><br/>
1.3 Exchanging DTOs – Synchronous Data Exchange&#160;<br/>
35<br/>
How can the acquisition of measured values now be coupled to processes in the ECU? Figure 19&#160;<br/>shows the relationship between calculation cycles in the ECU and the changes in parameters X&#160;<br/>and Y.<br/>
Calculation<br/>
Calculation<br/>
Calculation<br/>
cycle n<br/>
cycle n+1<br/>
cycle n+2<br/>
time<br/>
10<br/>
&#160; 8<br/>
&#160; 6<br/>
<b>X&#160;</b>&#160; 4&#160; 2&#160; 0<br/>
10<br/>
&#160; 8<br/>
&#160; 6<br/>
<b>Y&#160;</b>&#160; 4&#160; 2&#160; 0<br/>
E1<br/>
E1<br/>
E1<br/>
<b>Figure 19:</b><br/>
Read sensor X<br/>
Calculate Y = X<br/>
<b>Events in the ECU</b><br/>
Let’s have a look at the sequence in the ECU: When event E1 (= end of computation cycle) is&#160;<br/>reached, then all parameters have been acquired and calculations have been made. This means&#160;<br/>that all values must match one another and correlate at this time point. This means that we&#160;<br/>use&#160;an&#160;event-synchronous&#160;measurement&#160;method.&#160;This&#160;is&#160;precisely&#160;what&#160;is&#160;implemented&#160;with&#160;the&#160;<br/>help of the DAQ mechanism: When the algorithm in the Slave reaches the “Computational cycle&#160;<br/>completed” event, the XCP Slave collects the values of the measurement parameters, saves them&#160;<br/>in a buffer and sends them to the Master. This assumes that the Slave knows which parameters&#160;<br/>should be measured&#160;for which event.&#160;<br/>
An event does not absolutely have to be a cyclic, time-equidistant event, rather in the case of&#160;<br/>an engine controller, for example, it might be angle-synchronous. This makes the time inter-<br/>val between two events dependent on the engine rpm. A singular event, such as activation of a&#160;<br/>switch by the driver, is&#160;also an event that&#160;is not by any means&#160;equidistant in time.&#160;<br/>
The user selects the signals. Besides the actual measurement object, the user must select the&#160;<br/>underlying event for the measurement parameters. The events as well as the possible assign-<br/>ments of&#160;the measurement objects&#160;to the events&#160;must be stored in the A2L file.<br/>
<b>Figure 20:&#160;&#160;<br/>Event&#160;definition&#160;&#160;<br/>in an A2L</b><br/>
<hr/>
<a name=36></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-36_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-36_2.png"/><br/>
36<br/>
1 Fundamentals of the XCP protocol<br/>
In the normal case, it does not make any sense to be able to simultaneously assign a measured&#160;<br/>value to multiple events. Generally, a parameter is only modified within a single cycle (e.g. only&#160;<br/>at 10-ms intervals) and not in&#160;multiple cycles&#160;(e.g. at 10-ms&#160;and 100-ms intervals).&#160;<br/>
&#160;<br/>
<b>Figure 21:&#160;<br/>Allocation of&#160;<br/>“Triangle” to possible&#160;<br/>events in the A2L</b><br/>
Figure&#160;21&#160;shows&#160;that&#160;the&#160;“Triangle” parameter&#160;can&#160;in&#160;principle be&#160;measured with&#160;the&#160;1 ms,&#160;&#160;<br/>10 ms and 100 ms events. The default&#160;setting is 10 ms.<br/>
Measurement&#160;parameters&#160;are&#160;allocated&#160;to&#160;events&#160;in&#160;the&#160;ECU&#160;during&#160;measurement&#160;configuration&#160;<br/>by the user.<br/>
&#160;<br/>
<b>Figure 22: Selecting&#160;<br/>events (measurement&#160;<br/>mode) for each&#160;&#160;<br/>measurement parameter</b><br/>
After configuring the measured signals, the user starts the measurement. The XCP Master lists&#160;<br/>the&#160;desired measurement&#160;parameters&#160;in&#160;what are&#160;known as&#160;DAQ lists.&#160;In these&#160;lists,&#160;the&#160;mea-<br/>sured signals&#160;are each allocated to selected events. This&#160;configuration information is&#160;sent to the&#160;<br/>Slave before the actual start of measurement. Then the Slave knows which addresses it should&#160;<br/>read&#160;out&#160;and&#160;transmit&#160;when&#160;an&#160;event&#160;occurs.&#160;This&#160;distribution&#160;of&#160;the&#160;measurement&#160;into&#160;a&#160;con-<br/>figuration phase and a measurement phase was already mentioned at the very beginning of this&#160;<br/>chapter.&#160;<br/>
This solves both problems that occur in polling: bandwidth is used optimally, because the Mas-<br/>ter no&#160;longer needs to poll&#160;each value&#160;individually during the measurement and the&#160;measured&#160;<br/>values correlate with one another.&#160;<br/>
<hr/>
<a name=37></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-37_1.png"/><br/>
1.3 Exchanging DTOs – Synchronous Data Exchange&#160;<br/>
37<br/>
<b>Figure 23: Excerpt from the CANape Trace window of a DAQ measurement</b><br/>
Figure 23 illustrates an example of command-response communication (color highlighting)&#160;<br/>between Master and Slave (overall it is significantly more extensive and is only shown in part&#160;<br/>here for&#160;reasons of space).&#160;This involves&#160;transmitting&#160;the DAQ configuration to&#160;the Slave. After-<br/>wards, the measurement start is triggered and the Slave sends the requested values while the&#160;<br/>Master just listens.&#160;<br/>
Until&#160;now,&#160;the&#160;selection&#160;of&#160;a&#160;signal&#160;was&#160;described&#160;based&#160;on&#160;its&#160;name&#160;and&#160;allocation&#160;to&#160;a&#160;mea-<br/>surement event.&#160;But how exactly is the configuration transferred to the XCP Slave?<br/>
Let&#160;us&#160;look&#160;at&#160;the&#160;problem&#160;from&#160;the&#160;perspective&#160;of&#160;memory&#160;structure&#160;in&#160;the&#160;ECU:&#160;The&#160;user&#160;has&#160;<br/>selected signals and wishes to measure them. So that sending a signal value does not require&#160;<br/>the use of an entire message, the signals from the Slave are combined into message packets. The&#160;<br/>Slave does not create this definition of the combination independently, or else the Master would&#160;<br/>not be able to interpret the data when it received the messages. Therefore, the Slave receives&#160;<br/>an instruction from the&#160;Master describing&#160;how it should distribute the values&#160;to the messages.&#160;<br/>
The sequence in which the Slave should assemble the bytes into messages is defined in what&#160;<br/>are known as Object Description Tables (ODTs). The address and object length are important to&#160;<br/>uniquely identify a measurement object. An ODT provides the allocations of RAM contents from&#160;<br/>the Slave to assemble a message on the bus. According to the communication model, this mes-<br/>sage is transmitted as a DAQ&#160;DTO&#160;(Data Transfer Object).<br/>
<hr/>
<a name=38></a>38<br/>
1 Fundamentals of the XCP protocol<br/>
RAM Cells<br/>
ODT<br/>
0<br/>
address, length<br/>
1<br/>
address, length<br/>
2<br/>
address, length<br/>
3<br/>
address, length<br/>
...<br/>
PID<br/>
0<br/>
1<br/>
2<br/>
3<br/>
...<br/>
<b>Figure 24:&#160;<br/>ODT: Allocation&#160;&#160;<br/>of RAM addresses&#160;&#160;<br/>to&#160;DAQ&#160;DTO</b><br/>
Stated more precisely, an entry in an ODT list references a memory area in RAM by the address&#160;<br/>and length of&#160;the object.&#160;<br/>
After receiving the measurement start command, at some point an event occurs that is asso-<br/>ciated with a measurement. The XCP Slave begins to acquire the data. It combines the indi-<br/>vidual objects into packets and sends them on the bus. The Master reads the bus message and&#160;<br/>can interpret the individual data, because it has defined the allocation of individual objects to&#160;&#160;<br/>packets&#160;itself and therefore it knows their relationships.&#160;<br/>
However, each packet has&#160;a maximum&#160;number of useful&#160;bytes, which depends on the&#160;trans-<br/>port medium that is used. In the case of CAN, this amounts to seven bytes. If more data needs&#160;<br/>to be measured, an ODT is no longer sufficient. If two or more ODTs need to be used to trans-<br/>mit&#160;the measured&#160;values, then the&#160;Slave must&#160;be able&#160;to copy&#160;the data into the&#160;correct ODT&#160;and&#160;<br/>the Master must be able to uniquely identify the received ODTs. If multiple measurement inter-<br/>vals of the ECU are used, the relationship between ODT and measurement interval must also be&#160;<br/>uniquely identifiable.&#160;<br/>
<hr/>
<a name=39></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-39_1.png"/><br/>
1.3 Exchanging DTOs – Synchronous Data Exchange&#160;<br/>
39<br/>
The ODTs are combined into DAQ lists in the XCP protocol. Each DAQ list contains a number of&#160;<br/>ODTs and is assigned&#160;to an event.<br/>
ODT #2&#160;0&#160;address, length<br/>
1&#160;address, length<br/>
ODT #1&#160;0&#160;address, length<br/>
2&#160;address, length<br/>
1&#160;address, length<br/>
ODT #0&#160;0&#160;address, length<br/>
3&#160;address, length<br/>
2&#160;address, length<br/>
1&#160;address, length&#160;...<br/>
3&#160;address, length<br/>
PID=2&#160;0&#160;1&#160;2&#160;3&#160;...<br/>
2&#160;address, length<br/>
...<br/>
PID=1&#160;0&#160;1&#160;2&#160;3&#160;...<br/>
3&#160;address, length<br/>
<b>Figure 25:&#160;</b><br/>
...<br/>
PID=0&#160;0&#160;1&#160;2&#160;3&#160;...<br/>
<b>DAQ&#160;list&#160;<br/>with three ODTs</b><br/>
For example, if the user uses two measurement intervals (= two different events in the ECU),&#160;<br/>then two DAQ lists are&#160;used as well.&#160;One DAQ list&#160;is needed per event used. Each&#160;DAQ&#160;list contains&#160;<br/>the entries related to the ODTs and each ODT contains references to the values in the RAM cells.<br/>
DAQ&#160;lists&#160;are subdivided into the&#160;types: static,&#160;predefined and dynamic.&#160;<br/>
<b>Static DAQ lists:<br/></b>If the DAQ lists and ODT tables are permanently defined in the ECU, as is familiar from CCP, they&#160;<br/>are referred to as static DAQ lists. There is no definition of which measurement parameters exist&#160;<br/>in the ODT lists, rather only the framework that can be filled (in contrast to this, see predefined&#160;<br/>DAQ lists).<br/>
In&#160;static&#160;DAQ&#160;lists,&#160;the&#160;definitions&#160;are&#160;set&#160;in&#160;the&#160;ECU&#160;code&#160;and&#160;are&#160;described&#160;in&#160;the&#160;A2L.&#160;Figure&#160;<br/>26 shows an&#160;excerpt of an A2L, in&#160;which static&#160;DAQ lists are defined:<br/>
<b>Figure 26:&#160;<br/>Static DAQ lists</b><br/>
In&#160;the&#160;above&#160;example,&#160;there&#160;is&#160;a&#160;DAQ&#160;list&#160;with&#160;the&#160;number&#160;0,&#160;which&#160;is&#160;allocated&#160;to&#160;a&#160;10-ms&#160;event&#160;<br/>and can carry a maximum of two ODTs. The DAQ list with the number 1 has four ODTs and is linked&#160;<br/>to the 100 ms&#160;event.<br/>
<hr/>
<a name=40></a>40<br/>
1 Fundamentals of the XCP protocol<br/>
The A2L matches the contents of the ECU. In the case of static DAQ lists, the number of DAQ lists&#160;<br/>and the&#160;ODT lists&#160;they each contain&#160;are defined with the&#160;download of the application&#160;into the&#160;<br/>ECU. If the user&#160;now attempts to measure more signals with&#160;an event than fit in the allocated&#160;<br/>DAQ&#160;list, the Slave in the ECU will not be able to fulfill the requirements and the configuration&#160;<br/>attempt&#160;is terminated with&#160;an error. It&#160;does not matter that the other DAQ list is still fully avail-<br/>able and therefore actually still&#160;has transmission&#160;capacity.<br/>
<b>Predefined&#160;DAQ lists:<br/></b>Entirely predefined DAQ lists can also be set up in the ECU. However, this method is practically&#160;<br/>never used in ECUs due to the lack of flexibility for the user. It is different for analog measure-<br/>ment systems which transmit their data by XCP: Flexibility is unnecessary here, since the physi-<br/>cal structure of the measurement&#160;system&#160;remains&#160;the same&#160;over&#160;its life.<br/>
<b>Dynamic&#160;DAQ lists:&#160;<br/></b>A special aspect of the XCP protocol are the dynamic DAQ lists. It is not the absolute parameters&#160;<br/>of the DAQ and ODT lists that are permanently defined in the ECU code here, but just the param-<br/>eters of the memory area that can be used for the DAQ lists. The advantage is that the measure-<br/>ment tool has more latitude in putting together the DAQ lists &#160;and it can manage the structure&#160;<br/>of the DAQ lists dynamically.<br/>
Various functions especially designed for this dynamic management are available in XCP such as&#160;<br/>ALLOC_ODT&#160;which the Master can&#160;use to define the structure of a DAQ list in the Slave.<br/>
MIN_DAQ +&#160;DAQ_COUNT<br/>
DAQ1<br/>
DAQ0<br/>
DAQ<br/>
ALLOC_<br/>
ALLOC_ODT_ENTRY<br/>
ODT_ENTERIES_COUNT<br/>
T<br/>
ALLOC_OD<br/>
GRANULARITY_ODT_ENTRY_SIZE_DAQ<br/>
<b>Figure 27:&#160;</b><br/>
ODT_COUNT<br/>
<b>Dynamic DAQ lists</b><br/>
In putting together the DAQ lists, the Master must be able to distinguish whether dynamic or&#160;<br/>static&#160;DAQ lists are being used,&#160;how the parameters and structures of the DAQ lists look,&#160;etc.<br/>
<hr/>
<a name=41></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-41_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-41_2.png"/><br/>
1.3 Exchanging DTOs – Synchronous Data Exchange&#160;<br/>
41<br/>
<b>1.3.3&#160;STIM Calibration&#160;Method</b><br/>
The XCP calibration method was already introduced in the chapter about exchanging CTOs. This&#160;<br/>type of calibration exists in every XCP driver and&#160;forms the basis for calibrating objects&#160;in the&#160;<br/>ECU. However, no synchronization exists between sending a calibration command and an event&#160;<br/>in the ECU.<br/>
In contrast to this, the use of STIM is not based on exchanging CTOs, rather on the use of DTOs&#160;<br/>with communication that is synchronized to an event in the Slave. The Master must therefore&#160;<br/>know to which events in the Slave it can even synchronize at all. This information must also exist&#160;<br/>in the A2L.&#160;<br/>
<b>Figure 28: Event for DAQ and STIM</b><br/>
If the Master sends data to the Slave by STIM, the XCP Slave must be informed of the location in&#160;<br/>the packets at which the calibration parameters can be found. The same mechanisms are used&#160;<br/>here as are used for&#160;the DAQ lists.<br/>
<hr/>
<a name=42></a>42<br/>
1 Fundamentals of the XCP protocol<br/>
<b>1.3.4&#160;XCP Packet Addressing for DAQ and&#160;STIM&#160;</b><br/>
Addressing&#160;of the XCP&#160;packets&#160;was&#160;already&#160;discussed&#160;at&#160;the beginning of&#160;this&#160;chapter.&#160;Now&#160;that&#160;<br/>the concepts of DAQ, ODT and STIM have been introduced, XCP packet addressing will be pre-<br/>sented in greater&#160;detail.&#160;<br/>
During transmission of CTOs, the use of a PID is fully sufficient to uniquely identify a packet;&#160;<br/>however,&#160;this&#160;is no&#160;longer&#160;sufficient&#160;for&#160;transmitting&#160;measured&#160;values.&#160;The&#160;following&#160;figure&#160;<br/>offers an overview of the&#160;possible addressing that could occur with the DTOs:<br/>
<b>XCP DTO Packet</b><br/>
Identification Field&#160;Timestamp Field<br/>
Data Field<br/>
PID<br/>
PID&#160;DAQ<br/>
TS<br/>
PID<br/>
DAQ<br/>
TS<br/>
<b>Figure 29:&#160;&#160;<br/>Structure of the&#160;&#160;</b><br/>
PID&#160;FILL<br/>
DAQ<br/>
TIMESTAMP<br/>
DATA<br/>
<b>XCP packet for DTO&#160;<br/>transmissions</b><br/>
<b>Transmission&#160;type: “absolute ODT numbers”</b><br/>
Absolute means that the ODT numbers are unique throughout the entire communication – i.e.&#160;<br/>across all DAQ lists. In turn, this means that the use of absolute ODT numbers assumes a trans-<br/>formation&#160;step that utilizes&#160;a so-called&#160;“FIRST_PID for the DAQ list.<br/>
If a DAQ list starts with the PID j, then the PID of the first packet has the value j, the second&#160;<br/>packet has the PID value j&#160;+&#160;1, the third packet has the PID value j&#160;+&#160;2, etc. Naturally, the Slave&#160;<br/>must&#160;ensure&#160;here&#160;that&#160;the&#160;sum&#160;of&#160;FIRST_PID&#160;+&#160;relative&#160;ODT&#160;number&#160;remains&#160;below&#160;the&#160;PID&#160;of&#160;the&#160;<br/>next DAQ list.<br/>
DAQ&#160;list:&#160;0&#160;<br/>
≤&#160;PID&#160;≤&#160;k<br/>
DAQ&#160;list:&#160;k&#160;+&#160;1&#160;&#160;≤&#160;PID&#160;≤&#160;m<br/>DAQ&#160;list:&#160;m&#160;+&#160;1&#160;≤&#160;PID&#160;≤&#160;n<br/>etc.<br/>
<hr/>
<a name=43></a>1.3 Exchanging DTOs – Synchronous Data Exchange&#160;<br/>
43<br/>
In this&#160;case, the identification field&#160;is very simple:<br/>
Identification Field<br/>
PID<br/>
<b>Figure 30:&#160;<br/>Identification field&#160;</b><br/>
absolute ODT number<br/>
<b>with absolute&#160;&#160;<br/>ODT&#160;numbers</b><br/>
<b>Transmission&#160;type: “relative ODT numbers and absolute DAQ lists numbers”</b><br/>
In this case, both the DAQ lists number and the ODT number can be transmitted in the Identi-<br/>fication Field. However, there is still space left over in the number of bytes that is available for&#160;<br/>the information:<br/>
Identification Field<br/>
PID&#160;DAQ<br/>
<b>Figure 31:&#160;<br/>ID field with&#160;&#160;</b><br/>
absolute DAQ List number<br/>
<b>relative ODT and&#160;</b><br/>
relative ODT number<br/>
<b>absolute DAQ&#160;&#160;<br/>numbers (one byte)</b><br/>
In the figure, one byte is available&#160;for the DAQ number&#160;and one byte for the&#160;ODT number.<br/>
The maximum&#160;number of DAQ lists&#160;can be transmitted using two bytes:&#160;<br/>
Identification Field<br/>
PID<br/>
DAQ<br/>
<b>Figure 32:&#160;<br/>ID field with&#160;&#160;</b><br/>
absolute DAQ list number<br/>
<b>relative ODT and&#160;</b><br/>
relative ODT number<br/>
<b>absolute DAQ&#160;&#160;<br/>numbers (two bytes)</b><br/>
<hr/>
<a name=44></a>44<br/>
1 Fundamentals of the XCP protocol<br/>
If&#160;it&#160;is not&#160;possible&#160;to&#160;send three bytes, it&#160;is&#160;also&#160;possible&#160;to&#160;work&#160;with&#160;four bytes by&#160;using&#160;a fill&#160;<br/>byte:<br/>
Identification Field<br/>
PID&#160;FILL<br/>
DAQ<br/>
<b>Figure 33:&#160;</b><br/>
absolute DAQ list number<br/>
<b>ID field with relative&#160;</b><br/>
for alignement<br/>
<b>ODT&#160;and absolute DAQ&#160;<br/>numbers as well as fill&#160;</b><br/>
relative ODT number<br/>
<b>byte (total of four bytes)</b><br/>
How does the XCP Master now learn which method the Slave is using? First, by the entry in the&#160;<br/>A2L&#160;and&#160;second&#160;by&#160;the&#160;request&#160;to&#160;the&#160;Slave&#160;to&#160;determine&#160;which&#160;communication&#160;version&#160;it&#160;has&#160;<br/>implemented.<br/>
The response to the GET_DAQ_PROCESSOR_INFO request also sets the DAQ_KEY_BYTE that the&#160;<br/>Slave uses to inform the Master which transmission type is being used. If not only DAQ is being&#160;<br/>used, but also STIM, the Master must use the same method for STIM that the Slave uses for DAQ.<br/>
<b>1.3.5&#160;Bypassing&#160;=&#160;DAQ&#160;+ STIM&#160;</b><br/>
Bypassing&#160;can be implemented by joint use of DAQ and STIM (see Figure 8) and it represents&#160;<br/>a special form of a rapid prototyping solution. For a deeper understanding, however, further&#160;<br/>details&#160;are necessary, so this&#160;method is&#160;not explained until&#160;chapter 4.5 “Bypassing”.<br/>
<hr/>
<a name=45></a>1.4 XCP Transport Layers<br/>
45<br/>
<b>1.4 XCP Transport Layers&#160;</b><br/>
A main requirement in designing the protocol was that it must support different transport lay-<br/>ers. At the time this document was defined, the following layers had been defined: XCP on CAN,&#160;<br/>FlexRay, Ethernet, SxI and USB. The bus systems CAN, LIN and FlexRay are explained on the&#160;&#160;<br/>Vector E-Learning platform, as well as an introduction to AUTOSAR. For details see the website&#160;<br/>www.vector-elearning.com.<br/>
<b>1.4.1&#160;CAN&#160;</b><br/>
XCP was developed as a successor&#160;protocol of&#160;the CAN Calibration Protocols&#160;(CCP) and must&#160;<br/>therefore absolutely satisfy the requirements of the CAN bus. The communication over the CAN&#160;<br/>bus&#160;is&#160;defined&#160;by&#160;the&#160;associated&#160;description&#160;file.&#160;Usually&#160;the&#160;DBC&#160;format&#160;is&#160;used,&#160;but&#160;in&#160;some&#160;<br/>isolated cases&#160;the AUTOSAR&#160;format ARXML&#160;is already being used.&#160;<br/>
A CAN message is identified by a unique CAN identifier. The communication matrix is defined in&#160;<br/>the&#160;description&#160;file:&#160;Who&#160;sends which message and&#160;how are&#160;the&#160;eight useful&#160;bytes&#160;of&#160;the&#160;CAN bus&#160;<br/>being used? The following figure illustrates the process:&#160;<br/>
<b>Data</b><br/>
<b>CAN</b><br/>
<b>CAN</b><br/>
<b>CAN</b><br/>
<b>CAN</b><br/>
<b>Frame</b><br/>
<b>Node A</b><br/>
<b>Node B</b><br/>
<b>Node C</b><br/>
<b>Node D</b><br/>
ID=0x12<br/>
Sender<br/>
Receiver<br/>
ID=0x34<br/>
Sender<br/>
Receiver<br/>
Receiver<br/>
ID=0x52<br/>
Receiver<br/>
Sender<br/>
ID=0x67<br/>
Receiver<br/>
Receiver<br/>
Sender<br/>
Receiver<br/>
ID=0xB4<br/>
Receiver<br/>
Sender<br/>
<b>Figure 34:&#160;<br/>Definition of which&#160;</b><br/>
ID=0x3A5<br/>
Sender<br/>
Receiver<br/>
Receiver<br/>
Receiver<br/>
<b>bus nodes send&#160;<br/>which messages</b><br/>
The message with ID 0x12 is sent by CAN node A and all other nodes on the bus receive this mes-<br/>sage. In the framework of acceptance testing, CAN nodes C and D conclude that they do not&#160;<br/>need the message and they reject it. CAN node B, on the other hand, determines that its higher-<br/>level layers need the message and they provide them via the Rx buffer. The CAN nodes are inter-<br/>linked as&#160;follows:<br/>
<hr/>
<a name=46></a>46<br/>
1 Fundamentals of the XCP protocol<br/>
<b>CAN Node A</b><br/>
<b>CAN Node B</b><br/>
Host<br/>
Host<br/>
CAN Interface<br/>
CAN Interface<br/>
Tx<br/>
Rx<br/>
Tx<br/>
Rx<br/>
Buffer<br/>
Buffer<br/>
Buffer<br/>
Buffer<br/>
Acceptance<br/>
Acceptance<br/>
Test<br/>
Test<br/>
Send<br/>
Receive<br/>
Send<br/>
Receive<br/>
<b>CAN</b><br/>
Receive<br/>
Send<br/>
Receive<br/>
Send<br/>
Acceptance<br/>
Acceptance<br/>
Test<br/>
Test<br/>
Rx<br/>
Tx<br/>
Rx<br/>
Tx<br/>
Buffer<br/>
Buffer<br/>
Buffer<br/>
Buffer<br/>
CAN Interface<br/>
CAN Interface<br/>
Host<br/>
Host<br/>
<b>Figure 35:&#160;<br/>Representation&#160;</b><br/>
<b>CAN Node C</b><br/>
<b>CAN Node D</b><br/>
<b>of a CAN network</b><br/>
The XCP messages are not described in the communication matrix! If measured values are sent&#160;<br/>from the Slave via dynamic DAQ lists, e.g. with the help of XCP, the messages are assembled&#160;<br/>according to the signals selected by the user. If the signal selection changes, the message con-<br/>tents change as well. Nonetheless, there is a relationship between the communication matrix&#160;<br/>and XCP: CAN identifiers are needed to transmit the XCP messages over CAN. To minimize the&#160;<br/>number of&#160;CAN identifiers used, the XCP communication&#160;is limited to the&#160;use of just&#160;two CAN&#160;<br/>identifiers that are not being used in the DBC for “normal” communication. One identifier is&#160;<br/>needed to send information from the Master to the Slave; the other is used by the Slave for the&#160;<br/>response to the Master.<br/>
The excerpt from the CANape Trace window shows the CAN identifiers that are used under the&#160;<br/>“ID” column. In this example, just two different identifiers are used: 554 as the ID for the mes-<br/>sage from Master to Slave (direction Tx) and 555 for sending messages from the Slave to the&#160;<br/>Master (direction Rx).&#160;<br/>
<hr/>
<a name=47></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-47_1.png"/><br/>
1.4 XCP Transport Layers<br/>
47<br/>
<b>Figure 36: Example of XCP-on-CAN communication</b><br/>
In&#160;this&#160;example,&#160;the&#160;entire XCP&#160;communication&#160;is handled&#160;by&#160;the two CAN&#160;identifiers 554&#160;and&#160;<br/>555. These two IDs&#160;may not be allocated for other purposes&#160;in this network.&#160;<br/>
The CAN bus transmits a maximum of eight useful bytes per message. In the case of XCP, how-<br/>ever, we need information on the command used or the sent response. This is provided in the&#160;<br/>first byte of the CAN useful data. This means that seven bytes are available per CAN message for&#160;<br/>transporting useful data.&#160;<br/>
<b>XCP on CAN Message (Frame)</b><br/>
XCP Packet<br/>
XCP Tail<br/>
XCP Header<br/>
empty for CAN&#160;PID&#160;FILL&#160;DAQ<br/>
TIMESTAMP<br/>
DATA<br/>
Fill<br/>
Control Field<br/>
Control Field<br/>
&#160;empty for CAN<br/>
for CAN<br/>
<b>Figure 37: Representation of an XCP-on-CAN message</b><br/>
In CANape, you will find an XCP-on-CAN demo with the virtual ECU XCPsim. You can learn about&#160;<br/>more details&#160;of the standard in&#160;ASAM XCP on CAN&#160;Part 3 Transport Layer Specification.<br/>
<hr/>
<a name=48></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-48_1.png"/><br/>
48<br/>
1 Fundamentals of the XCP protocol<br/>
<b>1.4.2&#160;CAN FD</b><br/>
CAN FD (CAN with flexible data rate) is an extension of the CAN protocol developed by&#160;&#160;&#160;<br/>Robert&#160;Bosch GmbH.&#160;Its&#160;primary difference to&#160;CAN&#160;involves extending the useful&#160;data&#160;from 8&#160;to&#160;<br/>&#160;64 bytes. CAN FD also offers the option of sending the useful data at a higher data rate. After&#160;<br/>the arbitration phase, the data bytes are sent&#160;at a higher transmission rate than during the&#160;<br/>arbitration phase. This covers the need for greater bandwidth in automotive networks while pre-<br/>serving&#160;valuable experience&#160;gained from CAN&#160;development.<br/>The XCP-on-CAN-FD specification was defined in the XCP-on-CAN description of the XCP stan-<br/>dard, Version&#160;1.2.0&#160;(June 2013).&#160;<br/>&#160;<br/>
<b>Figure 38: Illustration of a CAN FD frame</b><br/>
Despite the largely similar modes of operation, this protocol requires extensions and modifica-<br/>tions to the hardware and software. Among other things, CAN FD introduces three new bits to&#160;<br/>the control field:<br/>&gt;&#160;&#160;Extended Data Length (EDL)<br/>&gt;&#160;&#160;Bit Rate Switch (BRS)&#160;<br/>&gt;&#160;&#160;Error State Indicator (ESI)<br/>
<hr/>
<a name=49></a>1.4 XCP Transport Layers<br/>
49<br/>
A&#160;recessive&#160;EDL&#160;bit&#160;(High&#160;level)&#160;distinguishes&#160;frames&#160;in extended&#160;CAN-FD&#160;format&#160;from&#160;those&#160;in&#160;<br/>standard CAN format, because they are identified by a dominant EDL bit (low level). Similarly, a&#160;<br/>recessive BRS bit causes the transmission of the data field to be switched to the higher bit rate.&#160;<br/>The&#160;ESI&#160;bit&#160;identifies&#160;the&#160;error&#160;state&#160;of&#160;a&#160;CAN&#160;FD&#160;node.&#160;Another&#160;four&#160;bits&#160;make&#160;up&#160;what&#160;is&#160;known&#160;<br/>as the Data Length Code (DLC), which represents the extended useful data length as a possible&#160;<br/>value of 12,&#160;16, 20,&#160;24, 32, 48 and 64 bytes.&#160;<br/>
The use of XCP on CAN FD assumes that a second transmission rate has been defined for the use-<br/>ful data in the A2L file. This is fully transparent to the user, who gets a complete A2L parameter-<br/>ization.&#160;A&#160;measurement&#160;configuration&#160;in&#160;the&#160;XCP&#160;master&#160;considers&#160;the&#160;maximum&#160;packet&#160;length,&#160;<br/>and the user&#160;does not need to make&#160;any other settings.&#160;<br/>
CAN FD is supported in CANape, Version 12.0 and higher. Every CAN hardware product from&#160;<br/>&#160;Vector which begins with “VN” supports&#160;the CAN FD transport protocol.<br/>
<hr/>
<a name=50></a>50<br/>
1 Fundamentals of the XCP protocol<br/>
<b>1.4.3&#160;FlexRay</b><br/>
A&#160;basic&#160;idea&#160;in&#160;the&#160;development&#160;of&#160;FlexRay&#160;was&#160;to&#160;implement&#160;a&#160;redundant&#160;system&#160;with&#160;deter-<br/>ministic&#160;time&#160;behavior.&#160;The&#160;connection&#160;redundancy&#160;was&#160;achieved&#160;by&#160;using&#160;two&#160;channels:&#160;chan-<br/>nel A and&#160;channel B. If&#160;multiple FlexRay nodes (= ECUs)&#160;are redundantly interconnected and&#160;<br/>one branch fails, the nodes can switch over to the other channel to make use of the connection&#160;<br/>redundancy.&#160;<br/>
Node K<br/>
Node L<br/>
Node M<br/>
Node N<br/>
Node O<br/>
CH A<br/>CH B<br/>
<b>Figure 39: Nodes K and L are redundantly interconnected</b><br/>
Deterministic behavior is achieved by transmitting data within defined time slots. Also defined&#160;<br/>here is which node sends which content in which time slot. These time slots are combined to&#160;<br/>form one cycle. The cycles repeat here, as long as the bus is active. The assembly of the time&#160;<br/>slots and their transport contents (who sends&#160;what at which time)&#160;is known as&#160;Scheduling.&#160;<br/>
Node K<br/>
Node L<br/>
Node M<br/>
Slot<br/>
Direction&#160;Frame<br/>
Slot<br/>
Direction&#160;Frame<br/>
Slot<br/>
Direction&#160;Frame<br/>
1<br/>
Tx<br/>
a<br/>
1<br/>
Tx<br/>
a<br/>
1<br/>
Tx<br/>
a<br/>
3<br/>
Rx<br/>
x<br/>
3<br/>
Rx<br/>
b<br/>
3<br/>
Rx<br/>
x<br/>
Frame: a<br/>
Frame: b<br/>
Frame: x<br/>
Frame: a<br/>
Frame: b<br/>
Frame: x<br/>
Slot 1<br/>
Slot 2<br/>
Slot 3<br/>
Slot 1<br/>
Slot 2<br/>
...&#160;Real-time<br/>
t1<br/>
t2<br/>
t3<br/>
t4<br/>
t5<br/>
t6<br/>
Communication Cycle<br/>
Next Communication Cycle<br/>
<b>Figure 40: Communication by slot definition</b><br/>
<hr/>
<a name=51></a>1.4 XCP Transport Layers<br/>
51<br/>
In the first communication cycle, node K sends frame a in slot 1. The scheduling is also stored in&#160;<br/>the software of nodes L and M. Therefore, the contents of frame a are passed to the next higher&#160;<br/>communication&#160;levels.&#160;<br/>
Scheduling is consolidated in a description file. This is not a DBC file, as in the case of CAN,&#160;<br/>rather it is a FIBEX file. FIBEX stands for “Field Bus Exchange Format” and could also be used&#160;<br/>for other bus systems. However, its current use is practically restricted to the description of the&#160;<br/>FlexRay bus. FIBEX is an XML format and the XCP-on-FlexRay specification relates to FIBEX Ver-<br/>sion 1.1.5 and FlexRay specification&#160;Version 2.1.<br/>
<b>Cycles</b><br/>
<b>Slot</b><br/>
<b>ECU</b><br/>
<b>Channel</b><br/>
<b>0</b><br/>
<b>1</b><br/>
<b>2</b><br/>
<b>3</b><br/>
<b>4</b><br/>
<b>5</b><br/>
<b>6</b><br/>
<b>...</b><br/>
<b>63</b><br/>
A<br/>
b&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
b&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
b&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
b&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
b&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
b&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
b&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
&#160;<br/>
b&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
&#160;1<br/>
Node K<br/>
B<br/>
b&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
b&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
b&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
b&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
b&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
b&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
b&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
&#160;<br/>
b&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
A<br/>
c&#160;&#160;[rep&#160;:&#160;&#160;4&#160;]<br/>
x&#160;&#160;[rep&#160;:&#160;&#160;2&#160;]<br/>
y&#160;&#160;[rep&#160;:&#160;&#160;4&#160;]<br/>
x&#160;&#160;[rep&#160;:&#160;&#160;2&#160;]<br/>
c&#160;&#160;[&#160;c<br/>
rep&#160;:&#160;&#160;4&#160;]<br/>
x&#160;&#160;[rep&#160;:&#160;&#160;2&#160;]<br/>
y&#160;&#160;[rep&#160;:&#160;&#160;4&#160;]<br/>
&#160;<br/>
x&#160;&#160;[rep&#160;:&#160;&#160;2&#160;]<br/>
&#160;2<br/>
Node M<br/>
B<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
A<br/>
a&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
a&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
a&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
a&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
a&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
a&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
a&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
&#160;<br/>
<b>Static Segment</b><br/>
a&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
&#160;3<br/>
Node L<br/>
B<br/>
d&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
d&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
d&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
d&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
d&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
d&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
d&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
&#160;<br/>
d&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
Node L<br/>
A<br/>
n&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
n&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
n&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
n&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
n&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
n&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
n&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
&#160;<br/>
n&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
&#160;4<br/>
Node O<br/>
B<br/>
m&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
m&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
m&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
m&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
m&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
m&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
m&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
&#160;<br/>
m&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
Node N<br/>
A<br/>
r&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
r&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
r&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
r&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
r&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
r&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
r&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
&#160;<br/>
r&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
&#160;5<br/>
B<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
A<br/>
&#160;6<br/>
Node K<br/>
B<br/>
o&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
o&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
o&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
o&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
o&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
o&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
o&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
&#160;<br/>
o&#160;&#160;[rep&#160;:&#160;&#160;1&#160;]<br/>
Node M<br/>
A<br/>
t&#160;&#160;[rep&#160;:&#160;&#160;2&#160;]<br/>
p&#160;&#160;[rep&#160;:&#160;&#160;4&#160;]<br/>
t&#160;&#160;[rep&#160;:&#160;&#160;2&#160;]<br/>
&#160;<br/>
t&#160;&#160;[rep&#160;:&#160;&#160;2&#160;]<br/>
p&#160;&#160;[rep&#160;:&#160;&#160;4&#160;]<br/>
&#160;<br/>
t&#160;&#160;[r&#160;&#160;<br/>
ep&#160;:&#160;&#160;2&#160;]<br/>
B<br/>
&#160;<br/>
<b>Dynamic Segment</b><br/>
Node L<br/>
A<br/>
&#160;u&#160;&#160;[rep&#160;:&#160;&#160;4&#160;]<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;u&#160;&#160;[rep&#160;:&#160;&#160;4&#160;]<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;7<br/>
Node L<br/>
B<br/>
v&#160;&#160;[rep&#160;:&#160;&#160;8&#160;]<br/>
A<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
Node O<br/>
B<br/>
w&#160;&#160;[rep&#160;:&#160;&#160;4&#160;]<br/>
w&#160;&#160;[rep&#160;:&#160;&#160;4&#160;]<br/>
<b>Figure 41: Representation of a FlexRay communication matrix&#160;</b><br/>
Another format for describing bus communication has been defined as a result of the develop-<br/>ment of AUTOSAR solutions: the AUTOSAR Description File, which is available in XML format. The&#160;<br/>definition of XCP-on-FlexRay was taken into account in the AUTOSAR 4.0 specification. However,&#160;<br/>at the time of publication of this book this specification has not yet been officially approved and&#160;<br/>therefore it&#160;will not be discussed&#160;further.&#160;&#160;<br/>
Due to other properties of the FlexRay bus, it is not sufficient to just give the slot number as&#160;<br/>a reference to the contents. One reason is that multiplexing is supported: whenever a cycle is&#160;<br/>repeated, the transmitted contents are not necessarily the same. Multiplexing might specify&#160;<br/>that a certain piece of information is&#160;only sent in the&#160;slot in every&#160;second pass.&#160;<br/>
<hr/>
<a name=52></a>52<br/>
1 Fundamentals of the XCP protocol<br/>
Instead of indicating the pure slot number, “FlexRay Data Link Layer Protocol Data Unit Identi-<br/>fiers”&#160;(FLX_LPDU_ID) are&#160;used,&#160;which&#160;can be&#160;understood&#160;as a&#160;type&#160;of generalized&#160;Slot&#160;ID.&#160;Four&#160;<br/>pieces of&#160;information are needed&#160;to describe such an LPDU:<br/>&gt;&#160;&#160;FlexRay Slot&#160;Identifier&#160;(FLX_SLOT_ID)<br/>&gt;&#160;Cycle Counter&#160;Offset (OFFSET)<br/>&gt;&#160;&#160;Cycle Counter&#160;Repetition (CYCLE_REPETITION)<br/>&gt;&#160;&#160;FlexRay Channel&#160;(FLX_CHANNEL)<br/>
<b>LPDU_ID</b><br/>
...<br/>
Channel A<br/>
...&#160;...<br/>
Channel B<br/>
Cycle ID&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;&#160; .&#160;&#160;.&#160;.&#160;...<br/>
.<br/>
.&#160;.&#160;.&#160;.&#160;.<br/>
.&#160;..&#160;..&#160;..&#160;..&#160;..&#160;..&#160;..&#160;..&#160;..<br/>
..&#160;..&#160;..&#160;..&#160;..<br/>
..&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;&#160; .&#160;&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
.&#160;..&#160;..&#160;..&#160;..&#160;..&#160;..&#160;..&#160;..&#160;..<br/>
.<br/>
...<br/>
.&#160;..&#160;..&#160;..&#160;..<br/>
...&#160;...<br/>
...&#160;...<br/>
...<br/>
<b>Figure 42:&#160;<br/>Representation of&#160;&#160;</b><br/>
Slot ID<br/>
<b>the FlexRay LPDUs</b><br/>
Scheduling also has effects on the use of XCP on FlexRay, because it defines what is sent pre-<br/>cisely. This cannot be readily defined in XCP; not until the measurement runtime does the user&#160;<br/>define which measured values are sent by assembling signals. This means that it is only possible&#160;<br/>to choose which aspect of XCP communication can be used in which LPDU: CTO or DTO from Mas-<br/>ter to Slave or from Slave to Master.<br/>
The following example illustrates this process: the XCP Master may send a command (CMD) in&#160;<br/>slot n and Slave A gives the response (RES) in slot n&#160;+&#160;2. XCP-on-FlexRay messages are always&#160;<br/>defined using&#160;LPDUs.<br/>
The A2L description file is needed for access to internal ECU parameters; the objects with their&#160;<br/>addresses in the ECU are defined in this file. In addition, the FIBEX file is necessary, so that&#160;<br/>the XCP Master knows which LPDUs it may send and to which LPDUs the XCP Slaves send their&#160;<br/>responses. Communication between XCP Master and XCP Slave(s) can only function&#160;through&#160;<br/>combination&#160;of the two files,&#160;i.e. by having&#160;an A2L file reference a FIBEX file.<br/>
<hr/>
<a name=53></a>1.4 XCP Transport Layers<br/>
53<br/>
Excerpt of an&#160;A2L with XCP-on-FlexRay parameter setting:<br/>&#160;&#160;&#160;…<br/>/begin XCP_ON_FLX<br/>&#160;&#160;&#160;…&#160;<br/>„XCPsim.xml“<br/>„Cluster_1“<br/>&#160;&#160;&#160;…<br/>
In this&#160;example, “XCPsim.xml”&#160;is the reference&#160;from the A2L file&#160;to the FIBEX file.&#160;<br/>
<b>XCP-dedicated LPDU_IDs</b><br/>
...<br/>
Channel A<br/>
...&#160;...<br/>
Channel B<br/>
Cycle ID&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;&#160; .&#160;&#160;.&#160;.&#160;...<br/>
.<br/>
.&#160;.&#160;.&#160;.&#160;.<br/>
.&#160;..&#160;.&#160;.<br/>
.&#160;.&#160;..&#160;.&#160;.<br/>
.&#160;.&#160;..&#160;..&#160;..<br/>
..&#160;..&#160;..&#160;..&#160;..<br/>
..&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;&#160; .&#160;&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
.&#160;..&#160;..&#160;..&#160;..&#160;..&#160;..&#160;..&#160;..&#160;..<br/>
.<br/>
...<br/>
.&#160;..&#160;..&#160;..&#160;..<br/>
...&#160;...<br/>
...&#160;...<br/>
<b>Figure 43:&#160;</b><br/>
...<br/>
<b>Allocation of&#160;&#160;<br/>XCP communication&#160;</b><br/>
Slot ID<br/>
<b>to LPDUs</b><br/>
You can read more details about XCP on FlexRay in CANape’s online Help. Supplied with CANape&#160;<br/>is the FIBEX Viewer, which lets users conveniently view the scheduling. It is easy to allocate the&#160;<br/>XCP messages to the LPDUs by making&#160;driver settings&#160;for the XCP-on-FlexRay device&#160;in CANape.<br/>
The protocol is explained in detail in ASAM XCP on FlexRay Part 3 Transport Layer Specification.&#160;<br/>You will find an XCP-on-FlexRay demo in CANape with the virtual ECU XCPsim. The demo requires&#160;<br/>real Vector&#160;FlexRay hardware.<br/>
<b>1.4.4&#160;Ethernet</b><br/>
XCP on Ethernet can be used with either TCP/IP or UDP/IP. TCP is a protected transport protocol&#160;<br/>on Ethernet, in which the handshake method is used to detect any loss of a packet. In case of&#160;<br/>packet loss, TCP organizes a repetition of the packet. UDP does not offer this protection mech-<br/>anism.&#160;If&#160;a packet is&#160;lost,&#160;UDP does&#160;not offer any&#160;mechanisms&#160;for&#160;repeated&#160;sending of&#160;the&#160;lost&#160;<br/>packet&#160;on the protocol level.&#160;<br/>
Not only can XCP on Ethernet be used with real ECUs, it can also be used for measurement and&#160;<br/>calibration of virtual ECUs. Here, a virtual ECU is understood as the use of code that would other-<br/>wise run in the ECU as an executable program (e.g. DLL) on the PC. Entirely different resources&#160;<br/>are available here&#160;compared to an ECU (CPU, memory, etc.).&#160;<br/>
<hr/>
<a name=54></a>54<br/>
1 Fundamentals of the XCP protocol<br/>
But first the actual protocol will be discussed. IP packets always contain the addresses of the&#160;<br/>sender and receiver. The simplest way to visualize an IP packet is as a type of letter that contains&#160;<br/>the addresses of the recipient and the sender. The addresses of individual nodes must always be&#160;<br/>unique. A unique address&#160;comprises the IP address and port number.&#160;<br/>
<b>XCP on Ethernet (TCP/IP and UDP/IP) Message (Frame)</b><br/>
XCP Header<br/>
XCP Packet<br/>
XCP Tail<br/>
empty for Ethernet<br/>
LEN<br/>
CTR<br/>
(TCP/IP and UDP/IP)<br/>
PID&#160;FILL&#160;DAQ<br/>
TIMESTAMP<br/>
DATA<br/>
Control Field<br/>
Length (LEN)<br/>
Control Field<br/>
for Ethernet<br/>
empty for Ethernet<br/>
(TCP/ IP and UDP/IP) &#160;<br/>
(TCP&amp;IP and UDP&amp;IP)<br/>
<b>Figure 44: XCP packet with TCP/IP or UDP/IP</b><br/>
The header consists of a Control Field with two words in Intel format (= four bytes). These words&#160;<br/>contain the length (LEN) and a counter (CTR). LEN indicates the number of bytes in the XCP&#160;<br/>packet. The CTR is used to detect the packet loss. UDP/IP is not a protected protocol. If a packet&#160;<br/>is lost, this is not recognized by the protocol layer. Packet loss is monitored by counter infor-<br/>mation. When the Master sends its first message to the Slave, it generates a counter number&#160;<br/>that is incremented with each additional transmission of a frame. The Slave responds with the&#160;<br/>same pattern: It increments its own counter with each frame that it sends. The counters of the&#160;<br/>Slave and the Master operate independently of one another. UDP/IP is well suited for sending&#160;<br/>measured&#160;values.&#160;If&#160;a&#160;packet&#160;is&#160;lost,&#160;then&#160;the&#160;measured&#160;values&#160;it&#160;contains&#160;are&#160;lost,&#160;resulting&#160;in&#160;<br/>a measurement gap. If this occurs infrequently, the loss might just be ignored. But if the mea-<br/>sured data is to be used as the basis&#160;for fast control,&#160;it might be advisable&#160;to use TCP/IP.<br/>
An Ethernet packet can transport multiple XCP packets, but an XCP packet may never exceed the&#160;<br/>limits of a UDP/IP packet. In the case of XCP on Ethernet, there is no “Tail”, i.e. an empty con-<br/>trol field.<br/>
You will find more detailed information on the protocol in ASAM XCP on Ethernet Part 3 Trans-<br/>port&#160;Layer&#160;Specification.&#160;In&#160;CANape,&#160;you&#160;will&#160;also&#160;find&#160;an&#160;XCP&#160;on&#160;Ethernet&#160;demo&#160;with&#160;the&#160;virtual&#160;<br/>ECU XCPsim or with virtual ECUs in the form of DLLs, which have been implemented by Simulink&#160;<br/>models and the Simulink&#160;Coder.<br/>
<hr/>
<a name=55></a>1.4 XCP Transport Layers<br/>
55<br/>
<b>1.4.5&#160;SxI&#160;</b><br/>
SxI is a collective term for SPI or SCI. Since they are not buses, but instead are controller inter-<br/>faces&#160;which&#160;are&#160;only&#160;suited&#160;for&#160;point-to-point&#160;connections,&#160;there&#160;is&#160;no&#160;addressing&#160;in&#160;this&#160;type&#160;<br/>of transmission. The communication between any two nodes runs either synchronously or&#160;<br/>asynchronously.<br/>
<b>XCP on Sxl Message (Frame)</b><br/>
XCP Header<br/>
XCP Packet<br/>
XCP Tail<br/>
LEN<br/>
CTR<br/>
PID&#160;FILL<br/>
DAQ<br/>
TIMESTAMP<br/>
DATA<br/>
FILL<br/>
CS<br/>
Control Field<br/>
Length (LEN)<br/>
Control Field<br/>
for SxI&#160;<br/>
for SxI<br/>
Checksum (CS)<br/>
<b>Figure 45: XCP-on-SxI packet</b><br/>
The XCP header consists of a control field with two pieces of information: the length LEN and&#160;<br/>the counter. The length of these parameters may be in bytes or words (Intel format). LEN indi-<br/>cates&#160;the number&#160;of bytes&#160;of&#160;the&#160;XCP&#160;packet.&#160;The&#160;CTR&#160;is&#160;used&#160;to&#160;detect&#160;the&#160;loss&#160;of&#160;a packet.&#160;This&#160;<br/>is&#160;monitored&#160;in&#160;the&#160;same&#160;way&#160;as&#160;for&#160;XCP&#160;on&#160;Ethernet:&#160;with&#160;counter&#160;information.&#160;Under&#160;certain&#160;<br/>circumstances it may be necessary to add fill bytes to the packet, e.g. if SPI is used in WORD or&#160;<br/>DWORD mode or to avoid the message being shorter than the minimal packet length. These fill&#160;<br/>bytes are appended in&#160;the control field.<br/>
You will find more detailed information on the protocol in ASAM XCP on SxI Part 3 Transport&#160;<br/>Layer Specification.<br/>
<b>1.4.6&#160;USB&#160;</b><br/>
Currently,&#160;XCP on USB has&#160;no practical&#160;significance.&#160;Therefore,&#160;no further&#160;mention will&#160;be made&#160;<br/>of this topic; rather we refer you to ASAM documents that describe the standard: ASAM XCP on&#160;<br/>USB Part&#160;3 Transport Layer Specification.<br/>
<b>1.4.7&#160;LIN&#160;</b><br/>
At this time, ASAM has not yet defined an XCP-on-LIN standard. However, a solution exists from&#160;<br/>Vector (XCP-on-LIN driver and CANape as XCP-on-LIN Master), which violates neither the LIN nor&#160;<br/>the XCP specification and is already being used on some customer projects. For more detailed&#160;<br/>information, please contact&#160;Vector.<br/>
<hr/>
<a name=56></a>56<br/>
1 Fundamentals of the XCP protocol<br/>
<b>1.5 XCP Services</b><br/>
This chapter contains a listing and explanation of other services that can be realized over XCP.&#160;<br/>They are all based on the already described mechanisms of communication with the help of CTOs&#160;<br/>and DTOs. Some XCP services have already been explained, e.g. synchronous data acquisition/<br/>stimulation&#160;and read/write access to device&#160;memory.&#160;<br/>The XCP specification does indeed uniquely define the different services; at the same time it&#160;<br/>indicates whether the service always needs to be implemented or whether it is optional. For&#160;<br/>example, an XCP Slave must support “Connect” for the Master to set up a connection. On the&#160;<br/>other hand, flashing over XCP is not absolutely necessary and the XCP Slave does not need to&#160;<br/>support it. This simply depends on the requirements of the project and the software. All of the&#160;<br/>services&#160;described in&#160;this chapter&#160;are optional.&#160;<br/>
<b>1.5.1&#160;Memory Page Swapping&#160;</b><br/>
As already explained in the description of calibration concepts, parameters are normally located&#160;<br/>in&#160;flash&#160;memory&#160;and are&#160;copied to&#160;RAM&#160;as necessary. Some&#160;calibration&#160;concepts&#160;offer&#160;the&#160;option&#160;<br/>of swapping memory segment pages from RAM and Flash. XCP describes a somewhat more gen-<br/>eral, generic approach, in which a memory segment may contain multiple swappable pages.&#160;<br/>Normally, this consists of a RAM&#160;page&#160;and a flash page.&#160;But multiple RAM&#160;pages or the lack of a&#160;<br/>flash page are conceivable as well.&#160;<br/>
For a better understanding of the XCP commands for page swapping, the concepts of sector, seg-<br/>ment and page will&#160;be explained&#160;once again at this&#160;point.<br/>
XCP access<br/>
Segment 1<br/>
Segment 1<br/>
Segment 1<br/>
2<br/>
Page&#160;0<br/>
Page&#160;1<br/>
Page&#160;2<br/>
Segmemt 1<br/>
Sector&#160;<br/>
ECU access<br/>
Segment 0<br/>
Page&#160;0<br/>
1<br/>
Segmemt 0<br/>
Sector&#160;<br/>
0<br/>
<b>Figure 46:&#160;</b><br/>
Sector&#160;<br/>
address<br/>
<b>Memory&#160;<br/>representation</b><br/>
<hr/>
<a name=57></a>1.5 XCP Services<br/>
57<br/>
From&#160;an XCP&#160;perspective,&#160;the&#160;memory&#160;of&#160;a Slave&#160;consists&#160;of a&#160;continuous&#160;memory&#160;that&#160;is&#160;<br/>addressed with a 40-bit width. The physical layout of the memory is based on sectors. Know-<br/>ledge&#160;of&#160;the&#160;flash&#160;sectors&#160;is&#160;absolutely&#160;necessary&#160;in&#160;flashing,&#160;because&#160;the&#160;flash&#160;memory&#160;can&#160;only&#160;<br/>be erased a block at a time.&#160;<br/>
The logical structure is based on what are known as segments; they describe where calibration&#160;<br/>data is located in memory. The start address and parameters of a segment do not have to be&#160;<br/>aligned with the start addresses and parameters of the physical sectors. Each segment can be&#160;<br/>subdivided into multiple pages. The pages of a segment describe the same parameters at the&#160;<br/>same addresses. The values of these parameters and read/write rights can be controlled indi-<br/>vidually&#160;for each page.&#160;<br/>
The allocation of an algorithm to a page within a segment must always be unique. Only one page&#160;<br/>may be active in a segment at any given time. This page is known as the “active page for the&#160;<br/>ECU in this segment.” The particular page that the ECU and the XCP driver actively access can be&#160;<br/>individually switched. No interdependency exists between these settings. Similar to the nam-<br/>ing convention for the ECU, the active page for XCP access is referred to as the “active page for&#160;<br/>XCP access&#160;in this segment”.&#160;<br/>
In turn, this applies to each individual segment. Segments must be listed in the A2L file and&#160;<br/>each segment gets a number that is used to reference the segment. Within an XCP Slave, the&#160;<br/>SEGMENT_NUMBER&#160;must always begin at 0 and it&#160;is then incremented in consecutive numbers.&#160;<br/>Each segment has at least one page. The pages are also referenced by numbers. The first page&#160;<br/>is PAGE 0. One byte is available for the number, so that a maximum of 255 pages can be defined&#160;<br/>per segment.&#160;<br/>
The Slave must initialize all pages for all segments. The master uses the command GET_CAL_PAGE&#160;<br/>to ask the Slave which page is currently active for the ECU and which page for XCP access. It&#160;<br/>can certainly be the case that mutual blocking may be necessary for the accesses. For exam-<br/>ple, the&#160;XCP Slave may not access&#160;a page, if this&#160;page is currently&#160;active for the ECU.&#160;As men-<br/>tioned, there may be a dependency – but not necessarily. It is a question of how the Slave has&#160;<br/>been implemented.&#160;<br/>
If&#160;the&#160;Slave&#160;supports&#160;the&#160;optional&#160;commands&#160;GET_CAL_PAGE and&#160;SET_CAL_PAGE,&#160;then&#160;it&#160;also&#160;<br/>supports what is known as page swapping. These two commands let the Master poll which pages&#160;<br/>are&#160;currently&#160;being&#160;used&#160;and&#160;if&#160;necessary&#160;it&#160;can&#160;swap&#160;pages&#160;for&#160;the&#160;ECU&#160;and&#160;XCP&#160;access.&#160;The&#160;XCP&#160;<br/>Master has full control over swapping of pages. The XCP Slave cannot initiate swapping by itself.&#160;<br/>But naturally the Master must respect any restrictions of the&#160;Slave implementation.&#160;<br/>
What is the benefit of swapping?<br/>First, swapping permits very quick changing of entire parameter sets – essentially a before-and-<br/>after comparison. Second, the plant remains in a stable state, while the calibrator performs&#160;<br/>extensive parameter changes on another page in the ECU. This prevents the plant from going&#160;<br/>into a critical or unstable&#160;state, e.g. due&#160;to incomplete datasets during parameter setting.&#160;<br/>
<hr/>
<a name=58></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-58_1.png"/><br/>
58<br/>
1 Fundamentals of the XCP protocol<br/>
<b>1.5.2&#160;Saving Memory&#160;Pages – Data Page Freezing&#160;</b><br/>
When a calibrator calibrates parameters on a page, there is the conceptual ability in XCP to save&#160;<br/>the data directly in the ECU. This involves saving the data of a RAM page to a page in nonvola-<br/>tile memory. If the nonvolatile memory is flash, it must be taken into account that the segment&#160;<br/>start address and the segment size might not necessarily agree with the flash sectors, which&#160;<br/>represents a problem in erasing and rewriting the flash memory (see ASAM XCP Part 2 Protocol&#160;<br/>Layer Specification).<br/>
<b>1.5.3&#160;Flash Programming&#160;</b><br/>
Flashing&#160;means&#160;writing&#160;data&#160;in an area&#160;of&#160;flash&#160;memory.&#160;This&#160;requires precise&#160;knowledge&#160;of&#160;how&#160;<br/>the memory is laid out. A flash memory is subdivided into multiple sectors (physical sections),&#160;<br/>which are described by a start address and a length. To distinguish them from one another, they&#160;<br/>each&#160;get&#160;a&#160;consecutive&#160;identification&#160;number.&#160;One&#160;byte&#160;is&#160;available&#160;for&#160;this&#160;number,&#160;resulting&#160;in&#160;<br/>a maximum&#160;of 255 sectors.&#160;<br/>
SECTOR_NUMBER&#160;[0, 1, 2 … 255]<br/>
The information about the flash sectors&#160;is also part of the A2L data set.<br/>
<b>Figure 47:&#160;<br/>Representation&#160;<br/>of driver settings&#160;&#160;<br/>for the flash area</b><br/>
<hr/>
<a name=59></a>1.5 XCP Services<br/>
59<br/>
Flashing can be implemented using what are referred to as “flash kernels”. A flash kernel is exe-<br/>cutable code that is sent to the Slave’s RAM area before the actual flashing; the kernel then han-<br/>dles communication with the XCP Master. It might contain&#160;the algorithm that is responsible&#160;for&#160;<br/>erasing the flash memory. For security and space reasons, very frequently this code is not per-<br/>manently stored in the ECU’s flash memory. Under some circumstances, a converter might be&#160;<br/>used, e.g. if&#160;checksum or similar&#160;computations need to be&#160;performed.<br/>
Flashing with XCP roughly subdivides&#160;the overall&#160;flash process into three areas:<br/>&gt;&#160;&#160;Preparation (e.g.&#160;for version control and therefore to&#160;check whether&#160;the new contents<br/>&#160;&#160;can even be flashed)<br/>&gt;&#160;&#160;Execution (the new contents are sent&#160;to the ECU)&#160;<br/>&gt;&#160;&#160;Post-processing&#160;(e.g. checksum checking&#160;etc.)<br/>
In the XCP standard, the primary focus is directed to the actual execution of flashing. Any-<br/>one who compares this operation to flashing over diagnostic protocols will discover that the&#160;<br/>process-specific elements, such as serial number handling with meta-data, are supported in&#160;<br/>a&#160;rather&#160;spartan&#160;fashion&#160;in&#160;XCP.&#160;Flashing&#160;in&#160;the&#160;development&#160;phase&#160;was&#160;clearly&#160;the&#160;main&#160;focus&#160;<br/>in its definition and not the complex process&#160;steps that are necessary in end-of-line&#160;flashing.<br/>
Therefore, what is important in the preparation phase is to determine whether the new con-<br/>tents are even relevant to the ECU. There are no special commands for version control. Rather&#160;<br/>the practice&#160;has been to support those commands&#160;specific to&#160;the project.&#160;<br/>
The following XCP commands are available:<br/>
PROGRAM_START: Beginning of the flash procedure<br/>This command indicates the beginning of the flash process. If the ECU is in a state that does not&#160;<br/>permit flashing (e.g. vehicle speed &gt; 0), the XCP Slave must acknowledge with an ERRor. The&#160;<br/>actual flash process may not begin until the PROGRAM_START has been successfully acknowl-<br/>edged by the Slave.<br/>
PROGRAM_CLEAR:&#160;Call the&#160;current flash memory erasing routine&#160;<br/>Before&#160;flash&#160;memory&#160;can&#160;be&#160;overwritten&#160;with&#160;new contents,&#160;it&#160;must&#160;first&#160;be&#160;cleared.&#160;The call&#160;of&#160;<br/>the erasing routine via this command must be implemented in the ECU or be made available to&#160;<br/>the ECU with the help of&#160;the flash kernel.<br/>
PROGRAM_FORMAT: Select the&#160;data format for&#160;the flash data&#160;<br/>The XCP Master uses this command to define the format (e.g. compressed or encrypted) in which&#160;<br/>the data are transmitted to the Slave. If the command is not sent, the default setting is non-<br/>compressed and non-encrypted transmission.<br/>
PROGRAM: Transfer the data to&#160;the XCP Slave<br/>For the users who are very familiar with flashing via diagnostics: this command corresponds to&#160;<br/>TRANSFERDATA in diagnostics. Using this command, data is transmitted to the XCP Slave, which&#160;<br/>is then stored in flash&#160;memory.<br/>
<hr/>
<a name=60></a>60<br/>
1 Fundamentals of the XCP protocol<br/>
PROGRAM_VERIFY: Request to check the new flash&#160;contents<br/>The Master can request that the Slave perform an internal check to determine whether the new&#160;<br/>contents are OK.&#160;<br/>
PROGRAM_RESET: Reset request to the Slave<br/>Request by the Master to the Slave to execute a Reset. Afterwards, the connection to the Slave&#160;<br/>is always terminated and a new CONNECT must&#160;be sent.<br/>
<b>1.5.4&#160;Automatic Detection&#160;of the Slave&#160;</b><br/>
The XCP protocol lets the Master poll the Slave about its protocol-specific properties. A number&#160;<br/>of commands&#160;are available for this.<br/>
GET_COMM_MODE_INFO<br/>The response to this command gives the Master information about the various communication&#160;<br/>options of the Slave, e.g. whether it supports block transfer or interleaved mode or which mini-<br/>mum time&#160;intervals the Master must maintain between&#160;Requests&#160;in these modes.&#160;<br/>
GET_STATUS<br/>The response to this request returns all current status information of the Slave. Which resources&#160;<br/>(calibration, flashing, measurement, etc.) are supported? Are any types of memory activities&#160;<br/>(DAQ&#160;list&#160;configuration,&#160;etc.)&#160;still&#160;running&#160;currently?&#160;Are DTOs&#160;(DAQ,&#160;STIM)&#160;being&#160;exchanged&#160;<br/>right&#160;now?<br/>
GET_DAQ_PROCESSOR_INFO<br/>The Master gets general information, which it needs to know about the Slave limitations: num-<br/>ber of predefined&#160;DAQ&#160;lists, available&#160;DAQ&#160;lists and events,&#160;etc.<br/>
GET_DAQ_RESOLUTION_INFO<br/>Other information about the DAQ capabilities of the Slave is exchanged via this command: max-<br/>imum number of parameters for an ODT for DAQ and for STIM, granularity of the ODT entries,&#160;<br/>number of bytes in time stamp transmission,&#160;etc.<br/>
GET_DAQ_EVENT_INFO<br/>When this command is&#160;used, the call is made once per ECU event. Information is transmitted&#160;<br/>here on whether the event can be used for DAQ, STIM or DAQ/STIM, whether the event occurs&#160;<br/>periodically and if so which cycle time&#160;it has, etc.<br/>
<hr/>
<a name=61></a>1.5 XCP Services<br/>
61<br/>
<b>1.5.5&#160;Block Transfer Mode for Upload, Download and Flashing&#160;</b><br/>
In the “normal” communication mode, each command from the Master is acknowledged by a&#160;<br/>response of the Slave. However, in some cases it may be desirable, for performance reasons, to&#160;<br/>use what is&#160;referred to as the block transfer mode.&#160;<br/>
Master<br/>
Slave<br/>
Request&#160;k<br/>
Part1<br/>
Part2<br/>
MIN_ST<br/>
Part3<br/>
MAX_BS<br/>
Response&#160;k<br/>
Request k+1<br/>
<b>Figure 48:&#160;<br/>Representation&#160;&#160;</b><br/>
Time<br/>
<b>of the block&#160;&#160;<br/>transfer mode</b><br/>
The&#160;use&#160;of&#160;such&#160;a&#160;method&#160;accelerates&#160;the&#160;procedure&#160;when&#160;transmitting&#160;large amounts&#160;of&#160;data&#160;<br/>(UPLOAD, SHORT_UPLOAD, DOWNLOAD, SHORT_DOWNLOAD and PROGRAM). The Master can find&#160;<br/>out whether the Slave supports this method with the request GET_COMM_MODE_INFO. You will&#160;<br/>find more&#160;on this in ASAM&#160;XCP Part 2 Protocol&#160;Layer Specification.<br/>
<hr/>
<a name=62></a>62<br/>
1 Fundamentals of the XCP protocol<br/>
<b>1.5.6&#160;Cold Start Measurement&#160;(start&#160;of measurement during power-on)&#160;</b><br/>
Even with the capabilities of XCP described to this point, it would be impossible to implement&#160;<br/>an event-driven measurement that can in practice be executed early in the ECU’s start phase.&#160;<br/>The reason is that the measurement must be configured before the actual measurement takes&#160;<br/>place.&#160;If&#160;one&#160;attempts&#160;to&#160;do&#160;this,&#160;the&#160;ECU’s&#160;start&#160;phase&#160;has&#160;long&#160;been&#160;over&#160;by&#160;the&#160;time&#160;the&#160;first&#160;<br/>measured values are transmitted. The approach that is used to overcome this problem is based&#160;<br/>on a simple&#160;idea.&#160;<br/>
It involves separating&#160;the configuration&#160;and the measurement in time.&#160;After the configura-<br/>tion phase, the measurement is not started immediately; rather the ECU is shut down. After a&#160;<br/>reboot, the XCP Slave accesses the existing configuration directly and immediately begins to&#160;<br/>send the first messages. The difficulties associated with this are obvious: the configuration of&#160;<br/>the DAQ lists is stored in RAM, and therefore the&#160;information no longer exists after a reboot.&#160;<br/>
To enable what is known as the RESUME mode to enable a Cold Start Measurement, a nonvolatile&#160;<br/>memory is needed in the XCP Slave which preserves its data even when it is not being supplied&#160;<br/>with power. EEPROMs are used in this method. In this context, it is irrelevant whether it is a real&#160;<br/>EEPROM or one that is emulated by a flash memory.<br/>
You will find more details in ASAM XCP Part 1 Overview&#160;Specification in the chapter 1.4.2.2&#160;<br/>“Advanced Features”.<br/>
<hr/>
<a name=63></a>1.5 XCP Services<br/>
63<br/>
<b>1.5.7&#160;Security Mechanisms with XCP&#160;</b><br/>
An unauthorized user should be prevented as much as possible from being able to make a con-<br/>nection to an ECU. The “seed &amp; key” method is available for checking whether or not a connec-<br/>tion&#160;attempt&#160;is&#160;authorized.&#160;The&#160;three&#160;different&#160;access&#160;types&#160;can&#160;be&#160;protected&#160;by&#160;seed&#160;&amp;&#160;key:&#160;<br/>measurement&#160;/&#160;stimulation, calibration&#160;and flashing.<br/>
The “seed&#160;&amp;&#160;key”&#160;method&#160;operates as&#160;follows: in&#160;the connect&#160;request by&#160;the Master,&#160;the Slave&#160;<br/>sends a random&#160;number (= seed) to the&#160;Master. Now, the Master must use an algorithm to&#160;gen-<br/>erate a response (=&#160;key). The key is sent&#160;to the Slave. The Slave also computes the expected&#160;<br/>response and compares the key of the Master with its own result. If the two results agree, both&#160;<br/>the Master and Slave have used the same algorithm. Then the Slave accepts the connection to&#160;<br/>the Master. If there is no&#160;agreement, the Slave declines&#160;communication&#160;with the&#160;Master.<br/>
Normally, the&#160;algorithm is&#160;available&#160;as&#160;a DLL&#160;in&#160;the&#160;Master. So,&#160;if&#160;a user&#160;has&#160;the&#160;“seed&#160;&amp;&#160;key”&#160;<br/>DLL and the A2L file, nothing stands in the way of accessing the ECU’s memory. When the ECU&#160;<br/>is&#160;approaching a&#160;production&#160;launch,&#160;the&#160;XCP&#160;driver&#160;is&#160;often&#160;deactivated.&#160;A&#160;unique&#160;sequence&#160;of&#160;<br/>individual&#160;diagnostic&#160;commands&#160;is&#160;usually&#160;used&#160;to&#160;restore&#160;XCP&#160;access&#160;to&#160;the&#160;ECU.&#160;This&#160;makes&#160;<br/>the XCP driver largely available even in production vehicles, but it is normally deactivated to&#160;<br/>protect against unauthorized manipulation of the ECU (see ASAM XCP Part 2 Protocol Layer&#160;<br/>Specification).&#160;<br/>
Whether or not seed &amp; key or deactivation of the XCP driver is used in a project is implementa-<br/>tion-specific and independent&#160;of the XCP specification.&#160;<br/>
<hr/>
<a name=64></a>64<br/>
<hr/>
<a name=65></a>2 ECU Description File A2L<br/>
65<br/>
<b>2 ECU Description File&#160;A2L</b><br/>
<hr/>
<a name=66></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-66_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-66_2.png"/><br/>
66<br/>
2 ECU Description File A2L<br/>
One reason why an A2L file is needed has already been named: to allocate symbolic names to&#160;<br/>addresses. For example, if a software developer has implemented a PID controller and assigned&#160;<br/>the names P1, I1 and D1 in his application for the proportional, integral and differential compo-<br/>nents, then the calibrator should be able to access these parameters with their symbolic names.&#160;<br/>Let us take the following&#160;figure as an example:<br/>
<b>Figure 49:&#160;<br/>Parameters in&#160;&#160;<br/>a calibration window</b><br/>
The&#160;user&#160;can&#160;conveniently&#160;modify&#160;values&#160;using&#160;symbolic&#160;names.&#160;Another&#160;example&#160;is&#160;provided&#160;by&#160;<br/>viewing signal&#160;variables&#160;that are measured from&#160;the ECU:<br/>
<b>Figure 50: Signal response over time&#160;</b><br/>
&#160;<br/>
In the legend, the user can read the logical&#160;names of the signals. The addresses at which the&#160;<br/>parameters were located in the ECU are of secondary importance in the offline analysis of val-<br/>ues. Naturally, the correct address is needed to request the values in the ECU, but the numeric&#160;<br/>value of the address itself is of no importance to the user. The user uses the logical name for&#160;<br/>selection and visualization purposes. That is, the user selects the object by its name and the XCP&#160;<br/>Master looks for the associated address and data&#160;type in the A2L.<br/>
<hr/>
<a name=67></a>2 ECU Description File A2L<br/>
67<br/>
Another attribute of a parameter might be the definition of a minimum or maximum value. The&#160;<br/>value of the object would then have to lie within these limits.&#160;Imagine that you as the software&#160;<br/>developer define a parameter that&#160;has a direct effect&#160;on a power&#160;output stage.&#160;You&#160;must now&#160;<br/>prevent&#160;the user – whatever&#160;the user’s&#160;reasons&#160;might&#160;be –&#160;from configuring&#160;the output&#160;stage&#160;<br/>that&#160;would&#160;result&#160;in&#160;catastrophic&#160;damage.&#160;You&#160;can&#160;accomplish&#160;this&#160;by&#160;defining&#160;minimum&#160;and&#160;<br/>maximum&#160;values in the&#160;A2L to limit&#160;the permitted&#160;values.&#160;<br/>
Rules&#160;for&#160;conversion&#160;between&#160;physical&#160;and&#160;raw&#160;values&#160;are also&#160;defined&#160;in&#160;the&#160;A2L.&#160;You&#160;can&#160;visu-<br/>alize a simple example of such a conversion rule in a sensor that has an 8-bit value. The numeric&#160;<br/>values output by the sensor lie between 0 and 255, but you wish to see the value as a percent-<br/>age value. Mapping of the sensor&#160;value [0&#160;…&#160;255] to [0&#160;…&#160;100&#160;%]&#160;is performed&#160;with a conver-<br/>sion&#160;rule,&#160;which in&#160;turn is&#160;stored in&#160;the&#160;A2L.&#160;If&#160;an object&#160;is&#160;measured,&#160;which&#160;exists&#160;as&#160;a&#160;raw&#160;value&#160;<br/>in the ECU and is also transmitted as such, the measurement and calibration tool uses the stored&#160;<br/>formula&#160;and visualizes the physical value.<br/>
Besides scalar parameters, characteristic curves and maps are frequently used. Some might uti-<br/>lize a proximity sensor such as a Hall sensor, which determines distance as a function of mag-<br/>netic field strength and you may wish to use this distance value in your algorithm. The magnetic&#160;<br/>field and distance value do not run linear to one another. This nonlinearity of values would make&#160;<br/>formulation of the algorithm unnecessarily difficult. With the help of a characteristic curve, you&#160;<br/>can first linearize the values before you input the values into your algorithm as input variables.<br/>
Another application area for characteristic maps is their use as substitutes for complex compu-<br/>tations. For example, if there is a relationship y = f(x) and the function f is associated with a lot&#160;<br/>of computing effort, it is often simpler to simply compute the values over the potential range of&#160;<br/>x in advance and store the results in the form of a table (= characteristic curve). If the value x&#160;<br/>is now in the ECU, the value y does not need to be computed at the controller’s runtime, rather&#160;<br/>the map returns the result y to the input variable x. It may be necessary to interpolate between&#160;<br/>two values,&#160;but that would be the extent of the&#160;calculations.&#160;<br/>
How is this characteristic curve stored in memory? Are all x values input first and then all y val-<br/>ues?&#160;Or&#160;does storage follow the pattern: x1,&#160;y1;&#160;x2,&#160;y2;&#160;x3,&#160;y3 …?&#160;Since&#160;various&#160;options&#160;are&#160;<br/>available,&#160;the type of memory storage is defined&#160;in a storage scheme in the A2L.&#160;<br/>
The convenience for the user comes from the ability to work with symbolic names for parame-<br/>ters, the direct look at the physical values and access to complex elements such as characteris-<br/>tic maps,&#160;without having to&#160;concern oneself with complex storage schemes.<br/>
Another advantage is offered by the communication parameters. They are also defined in the&#160;<br/>A2L. In the communication between the measurement and calibration tool and the ECU, the&#160;<br/>parameter&#160;set&#160;from&#160;the&#160;A2L&#160;is&#160;used.&#160;The&#160;A2L&#160;contains&#160;everything&#160;that&#160;the&#160;measurement&#160;and&#160;cal-<br/>ibration&#160;tool needs to communicate with&#160;the ECU.&#160;<br/>
<hr/>
<a name=68></a>68<br/>
2 ECU Description File A2L<br/>
<b>2.1 Setting Up an A2L File for an XCP Slave&#160;</b><br/>
The A2L file&#160;is an ASCII-readable&#160;file, which describes the following with the help of keywords:<br/>&gt;&#160;&#160;Interface-specific&#160;parameters&#160;between&#160;measurement&#160;and&#160;calibration&#160;tool&#160;and&#160;A2L&#160;file&#160;(the&#160;<br/>
description is located at the beginning of the A2L file and is located in what is referred to as&#160;<br/>the AML tree),<br/>
&gt;&#160;&#160;Communication&#160;to the ECU,<br/>&gt;&#160;&#160;Storage scheme for characteristic curves and maps (keyword RECORD_LAYOUT),<br/>&gt;&#160;&#160;Conversion rules for converting raw&#160;values to physical&#160;values (keyword&#160;COMPU_METHOD),<br/>&gt;&#160;&#160;Measurement parameters (keyword MEASUREMENT),<br/>&gt;&#160;&#160;Calibration&#160;parameters (keyword CHARACTERISTIC)&#160;and<br/>&gt;&#160;&#160;Events that are relevant for triggering a measurement&#160;keyword EVENT),<br/>
A summary of parameters and measurement parameters is made with the help of groups (keyword&#160;<br/>GROUP).<br/>
Example&#160;of a measurement parameter with the name “Shifter_B3”:<br/>
&#160; &#160; /begin MEASUREMENT&#160;Shifter_B3 “Single bit signal&#160;(bit from a&#160;byte shifting)”<br/>&#160; &#160; &#160; UBYTE HighLow 0 0 0 1<br/>&#160; &#160; &#160; READ_WRITE<br/>&#160; &#160; &#160; BIT_MASK&#160;0x8<br/>&#160; &#160; &#160; BYTE_ORDER&#160;MSB_LAST<br/>&#160; &#160; &#160; ECU_ADDRESS&#160;0x124C02<br/>&#160; &#160; &#160; ECU_ADDRESS_EXTENSION&#160;0x0<br/>&#160; &#160; &#160; FORMAT “%.3”<br/>&#160; &#160; &#160; /begin IF_DATA CANAPE_EXT<br/>&#160; &#160;&#160;&#160; &#160;&#160;100<br/>&#160; &#160; &#160; &#160; LINK_MAP&#160;“byteShift” 0x124C02 0x0 0 0x0 1 0x87 0x0<br/>&#160; &#160; &#160; &#160; DISPLAY 0 0 20<br/>&#160; &#160; &#160; /end IF_DATA<br/>&#160; &#160; /end MEASUREMENT<br/>
Example&#160;of a parameter map&#160;with the name&#160;KF1:<br/>
&#160; &#160; /begin CHARACTERISTIC KF1 “8*8 BYTE no axis”<br/>&#160; &#160; &#160; MAP 0xE0338&#160;__UBYTE_Z 0 Factor100 0 2.55<br/>&#160; &#160; &#160; ECU_ADDRESS_EXTENSION&#160;0x0<br/>&#160; &#160; &#160; EXTENDED_LIMITS 0 2.55<br/>&#160; &#160; &#160; BYTE_ORDER&#160;MSB_LAST<br/>&#160; &#160; &#160; BIT_MASK&#160;0xFF<br/>&#160; &#160; &#160; /begin AXIS_DESCR<br/>&#160; &#160; &#160; &#160; FIX_AXIS&#160;NO_INPUT_QUANTITY BitSlice.CONVERSION&#160;8 0 7<br/>&#160; &#160; &#160; &#160; EXTENDED_LIMITS 0 7<br/>&#160; &#160; &#160; &#160; READ_ONLY<br/>&#160; &#160; &#160; &#160; BYTE_ORDER&#160;MSB_LAST<br/>&#160; &#160; &#160; &#160; FORMAT “%.0”<br/>
<hr/>
<a name=69></a>2.2 Manually Creating an A2L File&#160;<br/>
69<br/>
&#160; &#160; &#160; &#160; FIX_AXIS_PAR_DIST 0 1 8<br/>&#160; &#160; &#160; /end AXIS_DESCR<br/>&#160; &#160; &#160; /begin AXIS_DESCR<br/>&#160; &#160; &#160; &#160; FIX_AXIS&#160;NO_INPUT_QUANTITY BitSlice.CONVERSION&#160;8 0 7<br/>&#160; &#160; &#160; &#160; EXTENDED_LIMITS 0 7<br/>&#160; &#160; &#160; &#160; READ_ONLY<br/>&#160; &#160; &#160; &#160; BYTE_ORDER&#160;MSB_LAST<br/>&#160; &#160; &#160; &#160; FORMAT “%.0”<br/>&#160; &#160; &#160; &#160; FIX_AXIS_PAR_DIST 0 1 8<br/>&#160; &#160; &#160; /end AXIS_DESCR<br/>&#160; &#160; &#160; /begin IF_DATA CANAPE_EXT<br/>&#160; &#160;&#160;&#160; &#160;&#160;100<br/>&#160; &#160; &#160; &#160; LINK_MAP&#160;“map3_8_8_uc”&#160;0xE0338 0x0 0 0x0 1 0x87 0x0<br/>&#160; &#160; &#160; &#160; DISPLAY 0 0 255<br/>&#160; &#160; &#160; /end IF_DATA<br/>&#160; &#160; &#160; FORMAT “%.3”<br/>&#160; &#160; /end CHARACTERISTIC<br/>
The ASCII text is not easy to understand. You will find a description of its structure in ASAM XCP&#160;<br/>Part 2 Protocol Layer Specification in chapter 2.<br/>
The sections below describe how to create an A2L. Let us focus on the actual contents of an A2L&#160;<br/>and&#160;their&#160;meanings&#160;and leave the&#160;details&#160;of&#160;the&#160;A2L&#160;description&#160;language&#160;to&#160;an&#160;editor.&#160;The&#160;A2L&#160;<br/>Editor that is supplied with CANape is used&#160;here.&#160;<br/>
<b>2.2 Manually Creating&#160;an A2L File&#160;</b><br/>
The A2L mainly describes the contents of the memory of the XCP Slave. The contents depend on&#160;<br/>the application in the Slave, which was developed as C code. After the compiler/linker run of&#160;<br/>the&#160;application&#160;code,&#160;important&#160;elements&#160;of&#160;an&#160;A2L&#160;file&#160;already&#160;exist&#160;in&#160;the&#160;linker-map&#160;file:&#160;the&#160;<br/>names&#160;of&#160;the&#160;objects,&#160;their&#160;data types&#160;and memory&#160;addresses.&#160;Still&#160;lacking&#160;are&#160;the&#160;parameters&#160;<br/>for&#160;communication&#160;between&#160;XCP Master&#160;and Slave.&#160;Other&#160;information&#160;is usually needed&#160;such as&#160;<br/>minimum and maximum values of parameters, conversion rules, storage schemes for character-<br/>istic&#160;maps etc.<br/>
Let us begin by creating an empty A2L and the communication parameters: If you wish to cre-<br/>ate&#160;an&#160;A2L&#160;that&#160;describes&#160;an&#160;ECU&#160;with&#160;an&#160;XCP-on-CAN&#160;interface,&#160;for&#160;example,&#160;you&#160;create&#160;a&#160;new&#160;<br/>device in CANape and select XCP on CAN as the interface. Then you can supplement this with&#160;<br/>other communication-specific information (e.g. CAN identifiers). After saving the file, you have&#160;<br/>an A2L that contains the entire communication content of the A2L. Still lacking are the defini-<br/>tions of the actual measurement&#160;and calibration&#160;parameters.&#160;<br/>
<hr/>
<a name=70></a>70<br/>
2 ECU Description File A2L<br/>
In the A2L Editor (available as part of CANape or as a separate tool), the linker-map file is asso-<br/>ciated&#160;to&#160;the&#160;A2L.&#160;In&#160;a&#160;selection&#160;dialog,&#160;the&#160;user&#160;can&#160;now&#160;select&#160;those&#160;parameters&#160;from&#160;the&#160;map&#160;<br/>file which it needs in the A2L: scalar measurement and calibration parameters, characteristic&#160;<br/>curves and maps. The&#160;user can gradually add the desired parameters to the A2L step by step and&#160;<br/>group them.&#160;Other object-specific information&#160;is also&#160;added using the editor.&#160;<br/>
What should be done when you modify your code, recompile it and link it? It is highly proba-<br/>ble that the addresses&#160;of objects&#160;will change. Essentially, it is&#160;not necessary&#160;to generate&#160;a new&#160;<br/>A2L. If you wish to have objects&#160;just added to the code also be available&#160;in the A2L, you must of&#160;<br/>course add them to the A2L. Address updating is always necessary in the A2L. This is done with&#160;<br/>the editor; it searches for the relevant entry in the linker-map file based on the name of the A2L&#160;<br/>object,&#160;reads&#160;out the address and updates it in the A2L.<br/>
If your application changes very dynamically – objects are renamed, data types are adapted,&#160;<br/>parameters are deleted and others added – then the manual work method is impractical. To gen-<br/>erate an A2L from a C code, other tools are available&#160;for automatic&#160;processing.&#160;<br/>
On the Vector homepage you will find information on the “ASAP2 Tool-Set” with which you can&#160;<br/>automate the generation of A2Ls&#160;from the source&#160;code in a batch process.<br/>
<b>2.3 A2L&#160;Contents versus&#160;ECU Implementation</b><br/>
When an XCP Master tool reads in an A2L that does not fully match the ECU, misunderstandings&#160;<br/>in the communication might occur. For example, another value related to time stamp resolution&#160;<br/>might be in the A2L file that differs from the value implemented in the ECU. If this is the case,&#160;<br/>the problem must be detected and solved. The user gets support from the Master, who can poll&#160;<br/>the Slave via&#160;the protocol to determine what&#160;was really implemented in the Slave.&#160;<br/>
XCP offers a number of functions that were developed for automatic detection of the Slave. Of&#160;<br/>course, this assumes that automatic detection is implemented in the Slave. If the Master polls&#160;<br/>the&#160;Slave&#160;and&#160;the&#160;Slave’s&#160;responses&#160;do&#160;not&#160;agree&#160;with&#160;the&#160;parameter&#160;set&#160;of&#160;the&#160;A2L&#160;description&#160;<br/>file, the Master must decide which settings to use. In CANape, the information that is read out&#160;<br/>by the Slave is&#160;given a higher priority than the&#160;information&#160;from the A2L.<br/>
<hr/>
<a name=71></a>2.3 A2L Contents versus ECU Implementation<br/>
71<br/>
Here&#160;is&#160;an&#160;overview of&#160;possible&#160;commands&#160;that&#160;are&#160;used&#160;to&#160;find&#160;out something&#160;about&#160;the&#160;XCP&#160;<br/>implementation in the Slave:<br/>
GET_DAQ_PROCESSOR_INFO<br/>Returns general&#160;information on the DAQ lists: MAX_DAQ, MAX_EVENT_CHANNEL,&#160;MIN_DAQ<br/>
GET_DAQ_RESOLUTION_INFO&#160;<br/>Maximum&#160;parameter of&#160;an ODT&#160;entry for DAQ/STIM,&#160;time interval information<br/>
GET_DAQ_EVENT_INFO (Event_channel_number)<br/>Returns&#160;information&#160;for&#160;a&#160;specific&#160;time&#160;interval:&#160;Name&#160;and&#160;resolution&#160;of&#160;the&#160;time&#160;interval,&#160;num-<br/>ber of DAQ lists&#160;that may be assigned&#160;to this time&#160;interval&#160;…<br/>
GET_DAQ_LIST_INFO (DAQ_List_Number)<br/>Returns information on the selected DAQ list: MAX_ODT, MAX_ODT_ENTRIES exist as predefined&#160;<br/>DAQ lists …<br/>
<hr/>
<a name=72></a>72<br/>
<hr/>
<a name=73></a>3 Calibration Concepts<br/>
73<br/>
<b>3 Calibration Concepts</b><br/>
<hr/>
<a name=74></a>74<br/>
3 Calibration Concepts<br/>
ECU parameters are constant parameters that are adapted and optimized during the develop-<br/>ment of the ECU or an ECU variant. This is an iterative process, in which the optimal value of a&#160;<br/>parameter is found by repeated measurements and changes.&#160;<br/>
The calibration concept answers the question of how parameters in the ECU can be changed&#160;<br/>during an ECU’s development and calibration phases. There is not one calibration concept that&#160;<br/>exists, rather several. Which concept is utilized usually depends very much on the capabilities&#160;<br/>and resources of the microcontroller&#160;that is&#160;used.&#160;<br/>Normally, parameters are stored in the production ECU’s flash memory. The underlying program&#160;<br/>variables are defined as constants in the software. To make parameters modifiable at runtime&#160;<br/>during an ECU’s&#160;development, additional&#160;RAM memory is needed.<br/>
A calibration concept is concerned with such questions as these: How do the parameters initially&#160;<br/>find their way from flash to RAM? How is the microcontroller’s access to RAM rerouted? What&#160;<br/>does the solution look like when there are more parameters than can be simultaneously stored&#160;<br/>in&#160;RAM? How&#160;are the parameters copied&#160;back&#160;into&#160;flash?&#160;Are changes&#160;to the&#160;parameters persis-<br/>tent, i.e.&#160;are they preserved when the ECU is turned&#160;off?<br/>A distinction is made between transparent and non-transparent calibration concepts. Transpar-<br/>ent means that the calibration tool does not need to be concerned with the above questions,&#160;<br/>because all&#160;necessary mechanisms are implemented in the ECU.&#160;<br/>Several&#160;methods are briefly introduced in the following.<br/>
<b>3.1 Parameters in Flash</b><br/>
The software developer defines in the source code whether a parameter is a variable or a con-<br/>stant, i.e.&#160;whether a parameter is stored in flash or in&#160;RAM memory.<br/>
C code example:&#160;<br/>
const float factor = 0.5;&#160;<br/>
The “factor” parameter represents a constant with the value 0.5. During compiling and linking&#160;<br/>of the code, memory space is provided in flash for the “factor” object. The object is allocated&#160;<br/>an address that lies in the data area of the flash memory. The value 0.5 is found at the relevant&#160;<br/>address in the hex file and the address appears in&#160;the linker-map&#160;file.<br/>
The simplest conceivable calibration concept involves modifying the value in C code, generating&#160;<br/>a new hex file and flashing. However, this method is very laborious, because every value change&#160;<br/>must be made in code, resulting in the need for a compiler/linker run with subsequent flashing.&#160;<br/>An&#160;alternative&#160;approach&#160;would be&#160;to&#160;only&#160;modify&#160;the value&#160;in&#160;the&#160;hex&#160;file&#160;and then&#160;reflash&#160;this&#160;<br/>file. Every calibration tool is capable of doing this. It is referred to as “offline calibration” of the&#160;<br/>hex file,&#160;which is a&#160;very commonly used&#160;method.<br/>
<hr/>
<a name=75></a>3.1 Parameters in Flash<br/>
75<br/>
Under some circumstances, with certain compilers it may be necessary to explicitly ensure that&#160;<br/>parameters are&#160;always&#160;also stored in&#160;flash&#160;memory&#160;and not&#160;integrated&#160;in&#160;the code,&#160;for&#160;exam-<br/>ple and therefore do not appear at all in the linker-map file. Usually, one does not want to leave&#160;<br/>to chance where a constant is created in flash memory. The necessary means for accomplish-<br/>ing this are almost always compiler-specific pragma instructions. To prevent the compiler from&#160;<br/>embedding them in the code, it is generally sufficient to use the “volatile” attribute for con-<br/>stant parameters. A typical&#160;definition&#160;of a flash constant appears as in the following example:<br/>&#160;<br/>C code example:&#160;<br/>
#pragma section&#160;“FLASH_Parameter”<br/>volatile&#160;const float factor = 0.5;&#160;<br/>
It is normally not possible to calibrate parameters in flash online. Indeed, most microcontrollers&#160;<br/>are able to program their flash themselves, which is necessary for the purposes of re-program-<br/>ming in the field. Nonetheless, flash memory always has the property of being organized into&#160;<br/>larger&#160;blocks&#160;(sectors),&#160;which&#160;can&#160;only&#160;be&#160;erased&#160;as&#160;a&#160;whole.&#160;It&#160;is&#160;practically&#160;impossible&#160;to&#160;flash&#160;<br/>just&#160;individual&#160;parameters,&#160;because&#160;the&#160;ECU&#160;normally&#160;does&#160;not&#160;have&#160;the&#160;resources&#160;to&#160;buffer&#160;the&#160;<br/>rest of the&#160;sector and reprogram&#160;it. In addition, this process would&#160;take too much time.<br/>
Some ECUs have the ability to store data in what is known as an EEPROM memory. In contrast to&#160;<br/>flash memories, EEPROM memories can erase and program each memory cell individually. The&#160;<br/>amount of available EEPROM memory is always considerably less than the available flash mem-<br/>ory and it is usually limited to just a few kilobytes. EEPROM memory is often used to store pro-<br/>grammable parameters in the service shop or to implement a persistence mechanism in the&#160;<br/>ECU, e.g. for the odometer. Online calibration would be conceivable here, but it is seldom used,&#160;<br/>because access&#160;to EEPROM&#160;cells is&#160;relatively slow&#160;and during the booting process&#160;EEPROM param-<br/>eters&#160;are usually&#160;copied over to RAM memory, where it&#160;is&#160;possible to&#160;access them&#160;directly.&#160;ECUs&#160;<br/>which have no EEPROM memory often implement what is known as an EEPROM emulation. In&#160;<br/>this method, multiple small flash sectors are used in alternation to record parameter changes,&#160;<br/>so that the last valid value can always be determined. Online calibration would also be conceiv-<br/>able with this method.<br/>In&#160;both&#160;cases,&#160;the&#160;relevant&#160;memory&#160;accesses&#160;would&#160;then&#160;be&#160;intercepted&#160;in&#160;the&#160;software&#160;com-<br/>ponents of the XCP driver and&#160;implemented with the software routines of the EEPROM or the&#160;<br/>EEPROM emulation. The Vector XCP Professional driver offers the software hooks needed for this.<br/>
<hr/>
<a name=76></a>76<br/>
3 Calibration Concepts<br/>
<b>3.2 Parameters in RAM</b><br/>
The most frequently used approach to modifying parameters at runtime (“online calibration”) is&#160;<br/>to create the parameters in&#160;the available RAM&#160;memory.&#160;<br/>
C code example:&#160;<br/>
#pragma section&#160;“RAM_Parameter”<br/>volatile&#160;float factor =&#160;0.5;&#160;<br/>
This defines the parameter “factor” as a RAM variable with the initial value 0.5. During compil-<br/>ing&#160;and&#160;linking&#160;of&#160;the&#160;code,&#160;memory&#160;space&#160;is&#160;reserved&#160;for&#160;the&#160;object&#160;“factor”&#160;in&#160;RAM&#160;and&#160;the&#160;<br/>associated RAM address appears in the linker-map file. The initial value 0.5 is stored in flash&#160;<br/>memory and at the relevant location in the hex file. The addresses of the initial values in flash&#160;<br/>memory are defined by parameterization of the linker, but they do not appear in the linker-map&#160;<br/>file.&#160;<br/>During&#160;booting&#160;of&#160;the&#160;ECU,&#160;all&#160;RAM&#160;variables&#160;are&#160;initialized&#160;once&#160;with&#160;their&#160;initial&#160;values&#160;from&#160;<br/>flash memory. This is usually executed in the start-up code of the compiler producer and the&#160;<br/>application programmer does not need to be concerned with it. The application uses the val-<br/>ues of parameters located in&#160;RAM and they can&#160;be modified via&#160;normal XCP memory accesses.&#160;<br/>
From the perspective of the ECU software, calibration parameters in RAM are always still&#160;<br/>unchangeable, i.e.&#160;the application itself&#160;does not change them. Many compilers discover this&#160;<br/>fact&#160;by&#160;code&#160;analysis&#160;and&#160;simply&#160;optimize&#160;the&#160;necessary&#160;RAM&#160;memory&#160;space&#160;away.&#160;Normally,&#160;<br/>it&#160;is&#160;therefore&#160;also&#160;necessary&#160;to&#160;prevent&#160;the&#160;compiler&#160;from&#160;optimizing&#160;by&#160;using&#160;the&#160;“volatile”&#160;<br/>attribute.<br/>
From the perspective of the calibration tool, the RAM area in which the parameters are located&#160;<br/>is referred to as calibration&#160;RAM (memory that can be calibrated).&#160;<br/>
FLASH<br/>
RAM<br/>
Calibration RAM<br/>
<b>Figure 51:&#160;</b><br/>
Parameters<br/>
<b>Initial parameter&#160;<br/>setting in RAM</b><br/>
The&#160;calibration&#160;RAM&#160;does&#160;not&#160;need&#160;to&#160;consist&#160;of&#160;a&#160;fully&#160;contiguous&#160;RAM&#160;area.&#160;It&#160;may&#160;also&#160;be&#160;dis-<br/>tributed into multiple areas or even in any desired way. Nonetheless, it offers significant advan-<br/>tages for organizing the parameters in just a few contiguous RAM areas and isolating them from&#160;<br/>other RAM parameters such as changing state variables and intermediate results. This is espe-<br/>cially important if offline calibration of the calibration RAM with a hex file should be enabled.&#160;<br/>At the user’s request, the calibration tool must be able to load the parameters that were mod-<br/>ified offline into the ECU during the&#160;transition from&#160;offline calibration to online&#160;calibration.&#160;<br/>
<hr/>
<a name=77></a>3.2 Parameters in RAM<br/>
77<br/>
This case&#160;occurs very&#160;frequently. For&#160;example, when&#160;calibrators reconnect with their&#160;ECU on the&#160;<br/>next&#160;work&#160;day, they want to&#160;resume&#160;work&#160;at the point&#160;at&#160;which&#160;they&#160;stopped&#160;the evening before.&#160;<br/>However, booting of the ECU causes the flashed contents to be copied to the RAM as an initial&#160;<br/>dataset.&#160;To&#160;let&#160;users&#160;resume&#160;with&#160;work&#160;accomplished&#160;on&#160;the&#160;previous&#160;day,&#160;the&#160;parameter&#160;set&#160;<br/>file saved the previous evening in the ECU’s RAM must be loaded. This loading process may be&#160;<br/>time&#160;optimized&#160;by limiting&#160;the&#160;number&#160;of&#160;necessary&#160;transmissions&#160;to&#160;a&#160;minimum.&#160;It&#160;is&#160;advanta-<br/>geous&#160;here&#160;if&#160;the&#160;tool&#160;can&#160;quickly&#160;and&#160;reliably&#160;determine&#160;–&#160;by&#160;forming&#160;a&#160;checksum&#160;over&#160;larger&#160;<br/>contiguous areas – whether there are differences. If there are no differences between the cal-<br/>ibration RAM contents in the ECU and the file modified using the tool, this area does not need&#160;<br/>to be transferred. If the memory area with the calibration parameters is not clearly defined, or&#160;<br/>if it includes parameters that are modified by the ECU software, a checksum calculation always&#160;<br/>shows a difference and the parameter values are transmitted, either from the ECU to the XCP&#160;<br/>Master or in a reverse direction. Depending on the transmission speed and amount of data, this&#160;<br/>transmission&#160;could take several minutes.&#160;<br/>
Another advantage of clearly defined memory segments is that the memory area for initial val-<br/>ues&#160;in&#160;flash&#160;memory&#160;can&#160;be&#160;used&#160;for&#160;offline&#160;calibration.&#160;The&#160;contents&#160;of&#160;the&#160;flash&#160;memory&#160;are&#160;<br/>defined&#160;using flashable hex files.&#160;If&#160;the calibration&#160;tool knows the&#160;location&#160;of parameters&#160;in the&#160;<br/>hex file, it can modify&#160;their values and implement new initial&#160;values in the ECU by&#160;flashing the&#160;<br/>modified&#160;hex file.&#160;<br/>The calibration tool not only needs to know the location of parameters in RAM, but also the ini-<br/>tial values in flash. A prerequisite is that the RAM memory segment must be initialized by copy-<br/>ing from an identically laid out memory segment in flash, as is the usual practice in most com-<br/>pilers/linkers. If the addresses of parameters in RAM are in the A2L file, it is only necessary to&#160;<br/>let the tool know the offset to the start address of the calibration RAM, which it must add to get&#160;<br/>to the start address of the relevant flash area. This offset then applies to each individual param-<br/>eter in the A2L.&#160;<br/>
The&#160;calibration&#160;tool&#160;can&#160;then&#160;either&#160;generate&#160;flashable&#160;hex&#160;files&#160;for&#160;this&#160;area&#160;itself,&#160;or&#160;it&#160;can&#160;<br/>place them directly on the original hex files of the linker to modify the initial values of param-<br/>eters in&#160;the hex file.<br/>
<hr/>
<a name=78></a>78<br/>
3 Calibration Concepts<br/>
<b>3.3 Flash&#160;Overlay</b><br/>
Many microcontrollers offer options for overlaying memory areas in flash with internal or exter-<br/>nal RAM. This process is referred to as flash emulation or flash overlay. A lot is possible, from&#160;<br/>the use of a Memory Management Unit all the way to dedicated mechanisms that precisely serve&#160;<br/>this purpose. In this case the parameters are created as parameters in flash just as in calibra-<br/>tion&#160;concept&#160;1.&#160;This&#160;method&#160;offers&#160;enormous&#160;advantages&#160;compared&#160;to&#160;the&#160;described&#160;calibration&#160;<br/>concept&#160;2 “Parameters in&#160;RAM”:<br/>&gt;&#160;&#160;No distinction is made between flash and RAM addresses. The flash addresses are always&#160;<br/>
located in the A2L file, the hex file and linker-map file. This produces clear relationships, the&#160;<br/>hex file&#160;is directly flashable and the A2L&#160;file matches it exactly.<br/>
&gt;&#160;&#160;The overlay can be activated or deactivated as a whole, which enables lightning-quick swap-<br/>
ping between values in flash and those in RAM. They are referred to as the RAM page and the&#160;<br/>flash&#160;page&#160;of&#160;a&#160;memory&#160;segment.&#160;XCP&#160;supports&#160;control&#160;of&#160;memory&#160;page&#160;swapping&#160;with&#160;special&#160;<br/>commands.&#160;<br/>
&gt;&#160;&#160;The memory pages might be swapped separately, e.g. for XCP access and ECU access, i.e. XCP&#160;<br/>
could access a memory page while the ECU software works with the other page. This permits&#160;<br/>such operations&#160;as downloading of&#160;the offline&#160;calibration&#160;data to RAM, while&#160;the ECU is&#160;still&#160;<br/>working&#160;with&#160;the&#160;flash&#160;data;&#160;this&#160;avoids&#160;potential&#160;inconsistencies&#160;that&#160;could&#160;be&#160;problematic&#160;<br/>on a running ECU.<br/>
&gt;&#160;&#160;The&#160;overlay&#160;with&#160;RAM&#160;does&#160;not&#160;need&#160;to&#160;be&#160;complete&#160;and&#160;it&#160;can&#160;be&#160;adapted&#160;to&#160;the&#160;application&#160;<br/>
case. It&#160;is possible to work with less RAM&#160;than with&#160;flash. More on this later.<br/>
A&#160;typical&#160;procedure for&#160;connecting&#160;the&#160;calibration&#160;tool&#160;to&#160;the&#160;ECU&#160;with&#160;the&#160;subsequent&#160;down-<br/>load of values&#160;that were calibrated offline appears as follows:<br/>
Connects to the ECU&#160;<br/>
CONNECT<br/>
Connects XCP Master to RAM page&#160;<br/>
SET_CAL_PAGE&#160;XCP to RAM<br/>
Checksum calculation&#160;<br/>
CALC_CHECKSUM<br/>
When a difference has been detected in the checksum calculation over the RAM area, first the&#160;<br/>user is normally asked how to proceed. Should the contents of ECU RAM be sent to the Master, or&#160;<br/>should&#160;the&#160;contents&#160;of&#160;a&#160;file&#160;on&#160;the&#160;Master&#160;page&#160;be&#160;sent&#160;to&#160;the&#160;ECU’s&#160;RAM?&#160;If&#160;the&#160;user&#160;decides&#160;to&#160;<br/>write the offline changes to the ECU, the subsequent process appears as follows:<br/>
ECU should use&#160;the dataset of the flash page&#160;&#160;<br/>
SET_CAL_PAGE&#160;ECU to FLASH<br/>
Copy file&#160;from Master to the RAM page&#160;&#160;<br/>
DOWNLOAD …<br/>
ECU should use&#160;the dataset of the RAM page&#160;<br/>
SET_CAL_PAGE&#160;ECU to RAM<br/>
Afterwards,&#160;the&#160;memory&#160;page&#160;is&#160;always&#160;switched&#160;over&#160;to&#160;RAM,&#160;so&#160;that&#160;parameters&#160;can&#160;be&#160;&#160;<br/>modified.&#160;But&#160;the user&#160;can also&#160;explicitly indicate which memory page&#160;should be&#160;active in&#160;the&#160;<br/>ECU. For example, the behavior of the RAM parameter set can be compared to that of the flash&#160;<br/>parameter set, or in an emergency it can be switched back to a proven parameter set in flash at&#160;<br/>lightning&#160;speed.<br/>
<hr/>
<a name=79></a>3.4 Dynamic Flash Overlay Allocation<br/>
79<br/>
<b>3.4 Dynamic Flash Overlay Allocation</b><br/>
The concepts for calibration RAM described so far are unproblematic if sufficient RAM is avail-<br/>able for all parameters. But what if the total number of parameters does not fit into the avail-<br/>able RAM area?&#160;<br/>
Here, it is advisable to overlay flash with RAM dynamically and do not overlay the affected flash&#160;<br/>memory with RAM until the actual write access to a parameter. This procedure can occur with a&#160;<br/>certain granularity and – depending on the implementation – it may be transparent to the cal-<br/>ibration tool from the XCP perspective. If the XCP driver detects a write access to flash in the&#160;<br/>ECU which would lead to a change, a part of calibration RAM is used to copy over the relevant&#160;<br/>part of flash and activate the overlay mechanism for this part. This involves allocating the RAM,&#160;<br/>i.e.&#160;in a fixed layout and it is&#160;identified&#160;as utilized.&#160;However, the&#160;resources of the calibration&#160;<br/>RAM are limited. During the calibration process, RAM area that has already been allocated is&#160;<br/>no longer released, so the available calibration RAM dwindles with further requests. If the RAM&#160;<br/>resources are used up and a new allocation is required, the user is informed of the exhausted&#160;<br/>RAM resources. The user is offered the option of flashing or saving the changes made up to that&#160;<br/>point.&#160;This&#160;frees&#160;up&#160;the&#160;allocated&#160;RAM&#160;area&#160;again&#160;and&#160;the&#160;user&#160;can&#160;once&#160;again&#160;calibrate.&#160;The&#160;<br/>variant&#160;in&#160;which the&#160;ECU&#160;autonomously&#160;flashes&#160;the&#160;previously&#160;changed&#160;parameters&#160;is&#160;usually&#160;<br/>ruled out here&#160;for the reasons already cited in calibration concept “Parameter in&#160;Flash”.<br/>
In some cases, the download of a parameter set created offline might not be executable due&#160;<br/>to insufficient RAM resources. The only alternative is to flash it. The user can always cancel the&#160;<br/>changes from the tool and this&#160;releases the&#160;allocated RAM blocks again.<br/>
In this concept, page swapping between the RAM and flash pages is also possible without any&#160;<br/>limitations.<br/>The parameters should be organized together in flash according to function, so that the avail-<br/>able RAM blocks can be used as efficiently as possible. The software developer then specifies&#160;<br/>that the parameters, which belong together thematically, also lie in a contiguous memory area.&#160;<br/>After copying to RAM, the parameters needed for tuning the particular function are fully ready&#160;<br/>for use.&#160;<br/>
<hr/>
<a name=80></a>80<br/>
3 Calibration Concepts<br/>
<b>3.5 RAM&#160;Pointer Based Calibration Concept per&#160;AUTOSAR</b><br/>
This concept does not require the use of an AUTOSAR operating system; it can even be used in a&#160;<br/>different&#160;environment&#160;–&#160;e.g.&#160;without&#160;an&#160;operating&#160;system.&#160;The&#160;concept&#160;exhibits&#160;a&#160;key&#160;similar-<br/>ity to the previous concept. The primary difference is that the substitution of flash for RAM is&#160;<br/>not implemented by hardware mechanisms, but by software mechanisms instead. The calibra-<br/>tion&#160;parameters&#160;are&#160;always&#160;referenced&#160;by&#160;pointers from&#160;the&#160;ECU&#160;software.&#160;Flash&#160;or&#160;RAM&#160;con-<br/>tents are accessed by changing this pointer. The flash parameters to be modified are copied to&#160;<br/>a defined block with available RAM. This method can be implemented fully transparently from&#160;<br/>the XCP perspective, just as in the previous method. As an alternative, the user of the calibra-<br/>tion tool can explicitly select the parameters to be modified by preselecting the desired param-<br/>eters. The advantage of this is that resource utilization and loading are visible to the user and&#160;<br/>the user is&#160;not surprised&#160;by a lack of memory in the midst of working.<br/>
<b>3.5.1&#160;Single Pointer Concept</b><br/>
The pointer table is located in RAM. When booting the ECU, all pointers indicate the parame-<br/>ter values in flash. The location and parameters of the calibration RAM are indeed known, but&#160;<br/>it does not yet contain any parameter values after booting. Initially, the application works&#160;<br/>entirely from flash.&#160;<br/>
FLASH<br/>
Pointertable<br/>
RAM<br/>
<b>Figure 52:&#160;</b><br/>
Parameters<br/>
<b>Initial situation&#160;&#160;<br/>after booting</b><br/>
When&#160;the&#160;user&#160;selects&#160;a&#160;parameter&#160;from&#160;the&#160;A2L&#160;file&#160;for&#160;the&#160;first&#160;time&#160;after&#160;booting&#160;and&#160;wishes&#160;<br/>to write access it, this triggers a copying operation within the ECU first. The XCP Slave deter-<br/>mines that the address to which the access should be made is located in the flash area, and it&#160;<br/>copies the parameter value to the calibration RAM. A change is also made in the pointer table&#160;<br/>to ensure that the application no longer gets the parameter value from flash, but instead from&#160;<br/>the RAM area:&#160;<br/>
<hr/>
<a name=81></a>3.5 RAM Pointer Based Calibration Concept per AUTOSAR<br/>
81<br/>
FLASH<br/>
Pointertable<br/>
RAM<br/>
<b>Figure 53:&#160;</b><br/>
Parameters<br/>
<b>Pointer change and&#160;<br/>copying to RAM</b><br/>
The application continues to get the parameter value via the pointer table. But since the pointer&#160;<br/>indicates the RAM&#160;address, the value is&#160;retrieved&#160;from there. As a&#160;result, the&#160;user can&#160;change&#160;<br/>the parameter value via XCP and observe the effects of the change in the measurement. The dis-<br/>advantage of this method is that an entry in a pointer table must be available for each parame-<br/>ter&#160;and in&#160;turn the method&#160;is&#160;associated&#160;with&#160;substantial&#160;additional&#160;RAM memory requirements&#160;<br/>for the pointer table.&#160;<br/>
The next figure illustrates&#160;the problem.&#160;Three&#160;parameters of&#160;a PID&#160;controller&#160;(P,&#160;I and&#160;D) are&#160;con-<br/>tained in an ECU’s flash area. The RAM addresses and parameter values in RAM are also already&#160;<br/>changed in the pointer table.<br/>
<b>Parameter&#160;Flash</b><br/>
<b>Pointertable</b><br/>
<b>RAM</b><br/>
Addr.<br/>
Content<br/>
Addr.<br/>
Addr.<br/>
Content<br/>
<b>P&#160;</b>0x0000100A&#160;&#160;0x11<br/>
0x000A100A<br/>
0x000A100A&#160;0x44<br/>
<b>I</b><br/>
0x000012BC&#160;&#160;0x22<br/>
0x000A100B<br/>
0x55<br/>
0x000A100B<br/>
<b>D&#160;</b>0x00007234&#160;&#160;0x33<br/>
0x000A100C<br/>
0x000A100C<br/>
0x66<br/>
<b>Figure 54: Pointer table for individual parameters</b><br/>
Calibration concepts are very important, because RAM resources are scarce. Large RAM pointer&#160;<br/>tables would make a concept self-defeating.&#160;<br/>
To avoid having to create a pointer for each individual parameter and having the method be&#160;<br/>used as such, the parameters can be combined into structures. This requires just one pointer&#160;<br/>per structure. When&#160;the user selects&#160;a parameter, not&#160;only is&#160;this parameter copied&#160;to RAM,&#160;but&#160;<br/>so is the entire associated structure. The granularity of the structures is of key importance here.&#160;<br/>With large structures only a few pointers are necessary. In turn, this means that with the deci-<br/>sion for a specific parameter, a rather large associated structure is copied to the RAM area and&#160;<br/>this&#160;can cause the limits&#160;of calibration RAM space to&#160;be reached quickly.&#160;<br/>
<hr/>
<a name=82></a>82<br/>
3 Calibration Concepts<br/>
Example:&#160;<br/>The calibration RAM should be 400 bytes in size. Four structures are defined in the software with&#160;<br/>the following parameters:<br/>
Structure&#160;A: 250 bytes<br/>Structure&#160;B: 180&#160;bytes<br/>Structure&#160;C: 120 bytes<br/>Structure&#160;D: 100 bytes<br/>
When the user selects a parameter from structure A, the 250 bytes are copied from flash to the&#160;<br/>calibration RAM, and the user has XCP access to all parameters located in structure A. If the cali-<br/>bration task is limited to the parameters of this structure, the calibration RAM is fully sufficient.&#160;<br/>However, if the user selects another parameter located in a different structure, e.g. structure&#160;<br/>C, these 120 bytes must also be copied to the calibration RAM. Since the calibration RAM can&#160;&#160;<br/>handle 400 bytes,&#160;the user can access&#160;all parameters of structures A and C simultaneously.<br/>
If another selected parameter is not located in structure C, but rather in structure B, the 180&#160;<br/>bytes of structure B would have to be copied to RAM in addition to the 250 bytes of structure A.&#160;<br/>However, since the space in RAM is inadequate for this, the user indeed has access to the param-<br/>eters of structure A, but not to the data of structure B, because the ECU cannot&#160;execute the copy&#160;<br/>command.<br/>
You can learn more about how this approach works in CANape. Start CANape with the&#160;&#160;“AUTOSAR&#160;<br/>Single Pointered Demo” project. You will find more information on its use in CANape on the&#160;<br/>“Introduction”&#160;page of the project.<br/>
You will find a source code example under the “Demos” category at the Vector Download Center.&#160;<br/>A&#160;code&#160;example&#160;on&#160;how&#160;to&#160;use&#160;the&#160;calibration&#160;concept&#160;is&#160;contained&#160;in&#160;the&#160;“XCP&#160;Sample&#160;Imple-<br/>mentation”&#160;under &lt;Installation&#160;DIR&gt;\Samples\CAN\CAN MPC55xx\XCPDemo.&#160;<br/>
<b>3.5.2&#160;Double Pointer Concept</b><br/>
A disadvantage of the single pointer concept is that memory page swapping is not easy to imple-<br/>ment. The calibration tool could simply describe the pointer table completely for page swap-<br/>ping, but this is not feasible in a short period of time without resulting in temporary inconsis-<br/>tencies and side effects. A tool-transparent implementation would double the memory space&#160;<br/>requirement&#160;for&#160;the&#160;pointer&#160;table,&#160;because&#160;when&#160;swapping&#160;the&#160;memory&#160;page&#160;into&#160;flash,&#160;a&#160;copy&#160;<br/>of the previous&#160;pointer table&#160;would have to be created with&#160;RAM pointers.<br/>
For applications with large pointer tables, a transparent implementation or a fully consistent&#160;<br/>swapping, there is the option of extending the method to a double pointer concept. To explain&#160;<br/>how this is&#160;done, we return once&#160;again&#160;to the initial&#160;RAM setting.&#160;<br/>
<hr/>
<a name=83></a>3.6 Flash Pointer Based Calibration Concept&#160;<br/>
83<br/>
Figure 55 represents the pointer table. It lies in RAM. As already mentioned, this table must be&#160;<br/>copied from flash into RAM. As a result, this table lies in flash memory. If another pointer is now&#160;<br/>used&#160;(a&#160;table&#160;pointer),&#160;which&#160;points&#160;to&#160;either&#160;the&#160;pointer&#160;table&#160;in&#160;RAM&#160;or&#160;in&#160;flash,&#160;one&#160;arrives&#160;<br/>at a double pointer solution.&#160;<br/>
FLASH<br/>
RAM<br/>
Pointertable<br/>
FLASH<br/>
Pointertable<br/>
RAM<br/>
<b>Figure 55:&#160;</b><br/>
Tablepointer<br/>
<b>Double pointer concept</b><br/>
The parameter values are initially accessed via the table pointer. If the table pointer indicates&#160;<br/>the&#160;pointer&#160;table&#160;in&#160;RAM,&#160;the&#160;application&#160;essentially&#160;accesses&#160;the&#160;actual&#160;parameters&#160;via&#160;the&#160;con-<br/>tents of the RAM pointer table. The low access speed and the creation of more program code are&#160;<br/>disadvantages&#160;of this solution.<br/>
<b>3.6 Flash&#160;Pointer Based Calibration Concept&#160;</b><br/>
This method was patented several years ago by the company ZF Friedrichshafen under the name&#160;<br/>“InCircuit2” and bears a strong resemblance to the pointer-based concept of AUTOSAR. Here&#160;<br/>too, the application in the ECU accesses parameter data using a pointer table. However, this&#160;<br/>pointer table is not located in RAM, but in flash instead. Changes to the pointer table can there-<br/>fore only be made by flash programming. A tool-transparent implementation is not possible.&#160;<br/>The advantage lies in the RAM memory that is saved since it no longer contains the pointer&#160;<br/>table.<br/>
You can find out how this approach works in CANape. Start CANape with the “InCircuit2” project.&#160;<br/>You will&#160;find more information&#160;on its use in&#160;CANape on the “Introduction”&#160;page of the&#160;project.<br/>
<hr/>
<a name=84></a>84<br/>
&#160;<br/>
<hr/>
<a name=85></a>4 Application Areas of XCP&#160;<br/>
85<br/>
<b>4 Application&#160;Areas of XCP</b><br/>
<hr/>
<a name=86></a>86<br/>
4 Application Areas of XCP<br/>
When ECU calibrators think about the use of XCP, they are usually fixated on use of the proto-<br/>col in the ECU.<br/>
Simulink<br/>
Slave<br/>
Prototype or<br/>ECU Hardware<br/>
Slave<br/>
<b>XCP</b><br/>
Measurement/<br/>Calibration&#160;<br/>
Master<br/>
Slave<br/>
PC<br/>
Hardware*<br/>
EXE/DLL<br/>
Slave<br/>
HIL/SIL Systems<br/>
Slave<br/>
<b>Figure 56:&#160;&#160;<br/>Application areas and&#160;</b><br/>
* Debug Interfaces, Memory Emulator, ...<br/>
<b>application cases</b><br/>
In a survey of development processes, one encounters many different solution approaches for&#160;<br/>the development of electronics and software. HIL (Hardware in the Loop), SIL (Software in the&#160;<br/>Loop)&#160;and&#160;Rapid&#160;Prototyping&#160;are&#160;keywords here and&#160;they&#160;describe&#160;different&#160;scenarios.&#160;They&#160;<br/>always&#160;have a&#160;“plant” and a “controller” in common.&#160;<br/>
Manipulated&#160;&#160;Disturbance&#160;<br/>
Offset<br/>
Variable<br/>
Variable<br/>
Reference&#160;Variable<br/>
Controlled&#160;Variable<br/>
Controller<br/>
Plant<br/>
(Set Value)<br/>
(Actual Value)<br/>
<b>Figure 57: Plants and controllers</b><br/>
In the context of automotive development, the controller is represented by the ECU and the&#160;<br/>plant is the physical system to be controlled such as the transmission, engine, side mirrors, etc.<br/>
The&#160;rough&#160;subdivision&#160;is&#160;made&#160;between&#160;different&#160;development&#160;approaches&#160;according&#160;to&#160;whether&#160;<br/>the&#160;controller&#160;or the&#160;plant&#160;runs in&#160;real or&#160;simulated mode.&#160;Some combinations&#160;will be&#160;described&#160;<br/>in greater detail.&#160;<br/>
<hr/>
<a name=87></a>4.1 MIL: Model in the Loop&#160;<br/>
87<br/>
<b>4.1 MIL: Model in the&#160;Loop&#160;</b><br/>
Simulink<br/>
<b>Controller Model</b><br/>
<b>Plant&#160;Model</b><br/>
<b>Figure 58:&#160;<br/>Model in the Loop&#160;&#160;<br/>in Simulink</b><br/>
In this development environment, both the controller and the plant are simulated as a model. In&#160;<br/>the example shown, both models run in Simulink as the runtime environment. The capabilities&#160;<br/>of the Simulink&#160;runtime&#160;environment are available&#160;to you for analyzing the behavior.&#160;<br/>
To realize the convenience of a measurement and calibration tool like CANape in an early devel-<br/>opment phase, an XCP Slave can be integrated in the controller model. In an authoring step,&#160;<br/>the Slave generates the A2L that matches the model and the user already has the full range of&#160;<br/>convenient operating features with visualization of process flows in graphic windows, access to&#160;<br/>characteristic curves and maps and much more.<br/>
Simulink<br/>
Controller Model<br/>
Plant Model<br/>
<b>CANape</b><br/>
<b>Figure 59:&#160;<br/>CANape as&#160;&#160;</b><br/>
<b>Simulink</b><br/>
<b>measurement and&#160;&#160;</b><br/>
<b>XCP Server</b><br/>
A2L<br/>
<b>calibration tool with&#160;<br/>Simulink models</b><br/>
Neither a code generation step nor instrumentation of the model is necessary for this. Time&#160;<br/>stamps are also included with transmissions over XCP. CANape completely adapts to the time&#160;<br/>behavior of the Simulink runtime environment here. Whether the model is running faster or&#160;<br/>slower&#160;than in real time&#160;is of no&#160;consequence.&#160;For example,&#160;if the functional&#160;developer&#160;uses the&#160;<br/>Simulink Debugger in the model to step through the model, CANape still takes the time trans-<br/>mitted&#160;via XCP as the reference&#160;time.&#160;<br/>
<hr/>
<a name=88></a>88<br/>
4 Application Areas of XCP<br/>
<b>4.2 SIL: Software in the Loop&#160;</b><br/>
Simulink<br/>
<b>Controller Model</b><br/>
<b>Plant Model</b><br/>
Code generation<br/>
<b>Figure 60:&#160;</b><br/>
<b>Controller Model</b><br/>
<b>Software in the&#160;&#160;</b><br/>
<b>Windows DLL</b><br/>
<b>Loop with Simulink&#160;<br/>environment</b><br/>
In this development step, code is generated from the model of the controller, which is then&#160;<br/>used in a PC-based runtime environment. Naturally, the controller may also have been devel-<br/>oped without any sort of model-based approach. The plant continues to be simulated. XCP can&#160;<br/>be used to measure and calibrate the controller. If the controller originates from a Simulink&#160;<br/>model, a code generation step (Simulink Coder with the target “CANape”) is used to generate&#160;<br/>the&#160;C code for a&#160;DLL and the&#160;associated&#160;A2L. If&#160;the Controller&#160;development is&#160;conducted based&#160;<br/>on manually written code, it&#160;is embedded in a C++&#160;project that is&#160;delivered with CANape.<br/>
After compiling and linking, the DLL is used in the CANape context. With the support of the XCP&#160;<br/>connection, the algorithms in the DLL can be measured and calibrated exactly as if the applica-<br/>tion were already&#160;integrated in an ECU.<br/>
Simulink<br/>
Controller Model<br/>
Plant Model<br/>
Code generation<br/>
Controller Model<br/>
<b>CANape</b><br/>
Windows DLL<br/>
A2L<br/>
<b>Figure 61:&#160;&#160;<br/>CANape as SIL&#160;&#160;<br/>development platform</b><br/>
<hr/>
<a name=89></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-89_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-89_2.png"/><br/>
4.3 HIL: Hardware in the Loop<br/>
89<br/>
<b>4.3 HIL: Hardware in the&#160;Loop&#160;</b><br/>
Many different kinds of HIL systems are available. They range from very simple, cost-effective&#160;<br/>systems all the way to very large and expensive expansion stages. The following figure shows&#160;<br/>the rough concept:<br/>
Controller Model<br/>
HIL Platform<br/>
I/O<br/>
Plant Model<br/>
<b>Figure 62:&#160;</b><br/>
ECU<br/>
<b>HIL&#160;solution</b><br/>
The controller&#160;algorithm&#160;runs in a microcontroller&#160;platform (e.g.&#160;the ECU), while&#160;the plant con-<br/>tinues to be simulated. Depending on the parameters and the complexity of the plant and the&#160;<br/>necessary I/O, requirements of the HIL platform and the associated costs can rise steeply. Since&#160;<br/>the ECU runs in real time,&#160;the model of the&#160;plant must also&#160;be computed in real time.<br/>
To now introduce XCP for optimization appears trivial, because another ECU is being added. The&#160;<br/>whole system looks like this:<br/>
Controller Model<br/>
A2L<br/>
HIL Platform<br/>
I/O<br/>
<b>CANape</b><br/>
<b>Figure 63:</b><br/>
Plant Model<br/>
<b>HIL&#160;with CANape&#160;&#160;<br/>as measurement&#160;&#160;</b><br/>
ECU<br/>
<b>and calibration tool</b><br/>
From CANape,&#160;the user has access&#160;to the algorithms in the ECU over XCP.&#160;<br/>
<hr/>
<a name=90></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-90_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-90_2.png"/><br/>
90<br/>
4 Application Areas of XCP<br/>
The Vector Tool CANoe is also used by many customers as a HIL system. With CANoe, a HIL sys-<br/>tem might&#160;look like this:<br/>
CANoe RT User PC<br/>
Ethernet<br/>
CANoe&#160;RT&#160;Server<br/>
CAN<br/>
LIN<br/>
Plant Model<br/>
MOST<br/>
A2L<br/>
FlexRay<br/>
Digital I/O<br/>
Analog I/O<br/>
XCP<br/>
<b>CANape</b><br/>
<b>Figure 64:&#160;</b><br/>
ECU<br/>
<b>CANoe as HIL system</b><br/>
The ability to access XCP data directly from CANoe for testing purposes results in the following&#160;<br/>variant&#160;as well:<br/>
CANoe RT User PC<br/>
A2L<br/>
Ethernet<br/>
CANoe&#160;RT&#160;Server<br/>
CAN<br/>
LIN<br/>
Plant Model<br/>
XCP<br/>
MOST<br/>
FlexRay<br/>
Digital I/O<br/>
Analog I/O<br/>
<b>Figure 65:&#160;<br/>CANoe as HIL&#160;&#160;<br/>system with XCP&#160;</b><br/>
ECU<br/>
<b>access to the ECU</b><br/>
Here the model of the plant runs on the CANoe real-time server. At the same time, XCP access&#160;<br/>to the ECU is also realized from CANoe. This gives a tool simultaneous access to the plant and&#160;<br/>the controller.&#160;<br/>
<hr/>
<a name=91></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-91_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-91_2.png"/><br/>
4.4 RCP: Rapid Control Prototyping&#160;<br/>
91<br/>
To round out the picture,&#160;yet another HIL solution&#160;option should be mentioned.&#160;The plant might&#160;<br/>also run as a DLL in CANape. This gives the user full access to the plant and to the controller&#160;<br/>over XCP.&#160;<br/>
ECU<br/>
<b>CANape</b><br/>
Plant Model<br/>
A2L<br/>
Windows DLL<br/>
XCP<br/>
Plant<br/>
A2L<br/>
XCP<br/>
ECU<br/>
<b>Figure 66: CANape as HIL solution</b><br/>
<b>4.4 RCP: Rapid Control Prototyping&#160;</b><br/>
In this development phase, the control algorithm runs on real-time hardware instead of an ECU.&#160;<br/>This&#160;situation&#160;often&#160;occurs&#160;when&#160;the&#160;necessary&#160;ECU&#160;hardware is&#160;not yet available.&#160;Several&#160;plat-<br/>forms come in question as suitable hardware: from simple evaluation boards all the way to spe-<br/>cial automotive-level hardware solutions, depending on which additional requirements need to&#160;<br/>be fulfilled.&#160;Here too, integration with XCP helps in setting&#160;up an OEM-independent tool&#160;chain.<br/>
Controller&#160;Model<br/>
<b>CANape</b><br/>
EVA Board<br/>
A2L<br/>
XCP<br/>
I/O<br/>
Plant<br/>
<b>Figure 67: RCP solution</b><br/>
The concepts “Rapid” and “Prototyping” describe the task very well. The aim is to develop a&#160;<br/>functional&#160;prototype&#160;as quickly as&#160;possible,&#160;to&#160;use and&#160;test&#160;it in&#160;the&#160;runtime&#160;environment.&#160;This&#160;<br/>just requires simple work steps&#160;throughout the entire process.<br/>
<hr/>
<a name=92></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-92_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-92_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-92_3.png"/><br/>
92<br/>
4 Application Areas of XCP<br/>
In the literature, the RCP approach is frequently subdivided into two areas: fullpassing and&#160;<br/>bypassing.<br/>
As depicted in Figure 67, the entire controller runs on separate real-time hardware. This method&#160;<br/>is known as fullpassing, because the entire controller runs on the controller hardware. It must&#160;<br/>have&#160;the&#160;necessary&#160;I/O&#160;to be&#160;able&#160;to&#160;interface&#160;with&#160;the&#160;plant.&#160;Very often,&#160;it&#160;is&#160;only&#160;possible&#160;to&#160;<br/>fulfill&#160;technical requirements for the&#160;I/O with suitable&#160;power electronics.&#160;<br/>
It&#160;is&#160;not&#160;only&#160;the&#160;I/O&#160;that&#160;represents&#160;a&#160;challenge;&#160;often&#160;functional&#160;elements&#160;of&#160;the&#160;ECU software&#160;<br/>(e.g. network management) are needed to enable functionality in a more complex network.&#160;<br/>However, if a complete ECU is used for Rapid Control Prototyping instead of a general control-<br/>ler platform, the complexity of the flash process, the size of the overall software, etc. all work&#160;<br/>against the requirement for “Rapid”&#160;development.&#160;<br/>
In summary: the use of an entire ECU as the runtime environment for the controller offers the&#160;<br/>advantage that the necessary hardware and software infrastructure for the plant exists. The dis-<br/>advantage lies&#160;in the high degree of complexity.<br/>The concept of bypassing was developed to exploit the advantages of the ECU infrastructure&#160;<br/>without&#160;being burdened by the disadvantages of high complexity.&#160;<br/>
<b>4.5 Bypassing&#160;</b><br/>
In Figure 68, the ECU is connected to the plant. The necessary I/O and software components are&#160;<br/>available in the ECU. In the bypassing hardware, an algorithm A1 runs, which occurs in Version&#160;<br/>A of the ECU. A1 is a new variant of the algorithm and should now be tried out on the real plant.<br/>&#160;<br/>
ECU<br/>
A2L<br/>
XCP<br/>
Bypassing Hardware<br/>
<b>CANape</b><br/>
Bypassing<br/>Hardware<br/>
A2L<br/>
XCP<br/>
I/O<br/>
Controller Model<br/>
ECU<br/>
Plant<br/>
<b>Figure 68: Basic principle of bypassing</b><br/>
<hr/>
<a name=93></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-93_1.png"/><br/>
4.5 Bypassing&#160;<br/>
93<br/>
The bypassing hardware (a VN8900 device in the figure) and the ECU are interconnected over&#160;<br/>XCP. One goal here is to get the data needed for algorithm A1 from the ECU by DAQ; another&#160;<br/>goal is to stimulate the results of A1 back into the ECU. The following figure illustrates the sche-<br/>matic&#160;flow:<br/>
Bypassing Hardware<br/>
Algorithm A1<br/>
<b>2.</b><br/>
Bypassing<br/>
Coordinator<br/>
<b>3.</b><br/>
<b>1.&#160;XCP&#160;4.</b><br/>
Algorithm A<br/>
ECU<br/>
<b>Figure 69:&#160;<br/>Bypassing&#160;flow</b><br/>
Depicted in the ECU is a blue function block in which the algorithm A runs. To ensure that A1 can&#160;<br/>now be used, the data enters algorithm A as an input variable and it is measured from the ECU&#160;<br/>by DAQ. In step 1, the bypassing coordinator accepts the data and in step 2 it passes the data to&#160;<br/>algorithm A1. A1 is computed by the bypassing hardware and in step 3 the result is passed back&#160;<br/>to the bypassing coordinator; in step 4, it is transmitted to the ECU by STIM. The data is written&#160;<br/>to the “location” at which the next function block in the Slave expects its input variables. This&#160;<br/>makes it possible to use the value computed by algorithm A1 and not from A in the ECU’s over-<br/>all control process. This method permits using a combination of the rapid substitution of algo-<br/>rithms&#160;on the bypassing&#160;hardware that incorporates the I/O&#160;and the ECU’s basic&#160;software.&#160;<br/>
<hr/>
<a name=94></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-94_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-94_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-94_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-94_4.png"/><br/>
94<br/>
4 Application Areas of XCP<br/>
Of&#160;course,&#160;the&#160;performance&#160;limits&#160;of&#160;an&#160;XCP-on-CAN&#160;driver&#160;also&#160;affect&#160;bypassing. If&#160;short&#160;bypass-<br/>ing times are needed, access to the ECU by DAQ and STIM may also be performed via the con-<br/>troller’s debugging or trace interfaces. The Vector VX1000 measurement and calibration hard-<br/>ware&#160;converts the data&#160;into an&#160;XCP-on-Ethernet data&#160;stream from&#160;the&#160;controller&#160;interface.&#160;In&#160;<br/>this&#160;process, up to one megabyte of data can be transported into the&#160;ECU.<br/>
XCP<br/>
Bypassing<br/>
Bypassing Hardware<br/>
<b>CANape</b><br/>
Hardware<br/>
A2L<br/>
XCP<br/>
Measurement &amp; Calibration<br/>Hardware VX1000<br/>
Debugging and&#160;Trace Interface<br/>
I/O<br/>
Controller Model<br/>
ECU<br/>
Plant<br/>
<b>Figure 70: Bypassing with real-time bypassing hardware and fast ECU access</b><br/>
<hr/>
<a name=95></a>4.6 Shortening Iteration Cycles with Virtual ECUs<br/>
95<br/>
<b>4.6 Shortening Iteration Cycles with Virtual&#160;ECUs&#160;</b><br/>
Stimulation&#160;with data is necessary to optimize the algorithm in the ECU with the help of XCP.&#160;<br/>This can be done in the ECU in the framework of test drives. But there is yet another solution&#160;<br/>that is available with XCP, in which the algorithm does not run on an ECU; rather it runs on the&#160;<br/>PC in the form of executable code or as a model in Simulink in the form of a “virtual ECU.” This&#160;<br/>virtual ECU does not need to run in real time, because in this case no connection to a real system&#160;<br/>exists.&#160;It can run significantly faster – depending on the&#160;PC’s computing power.&#160;<br/>
The algorithm is stimulated by a previously logged measurement file, which contains all signals&#160;<br/>that are needed as input signals for the algorithm. The connection to CANape is set up over XCP.&#160;<br/>The user can perform the parameterization and measurement configuration. Afterwards, exe-<br/>cution is started. Here the data from the test drive is fed into the algorithm as stimulation&#160;and&#160;<br/>the desired measurement parameters from the application are simultaneously measured out and&#160;<br/>saved to a measurement&#160;file. &#160;<br/>
Para-<br/>
MDF<br/>
meter<br/>
test&#160;drive<br/>
Application<br/>
5. Analyze<br/>
1.&#160;Set parameters<br/>
2.&#160;Start<br/>
<b>Simulink/</b><br/>
<b>CANape</b><br/>
<b>DLL</b><br/>
3. Send test&#160;drive data<br/>
4. Measurement data<br/>
Slave<br/>
<b>Figure 71:&#160;&#160;</b><br/>
New<br/>
<b>Short calibration&#160;</b><br/>
MDF<br/>
<b>cycles with&#160;&#160;<br/>virtual ECUs</b><br/>
<hr/>
<a name=96></a>96<br/>
4 Application Areas of XCP<br/>
After the calculation has been completed, a new measurement file is available to the user for&#160;<br/>analysis of ECU behavior. The length of time of the new measurement file precisely matches the&#160;<br/>length of the input measurement file. If the duration of a test drive is one hour, the algorithm&#160;<br/>on the PC might calculate the entire test drive in just a few seconds. Then a measurement result&#160;<br/>exists, which corresponds to a test of one hour duration. Based on the data analysis, the user&#160;<br/>makes decisions&#160;about parameterization and the iteration cycle&#160;is repeated.&#160;<br/>&#160;<br/>
<b>CANape</b><br/>
<b>Application as EXE or DLL on&#160;PC</b><br/>
Parameterization<br/>
Set values in<br/>
via XCP<br/>
workspace&#160;&#160;<br/>
Start<br/>
Start<br/>
Send measurement<br/>
data<br/>
Calculate model<br/>
Receive new<br/>
Send measurement&#160;<br/>
measurement data<br/>
values from the model<br/>
Analyze the<br/>
End model calculation<br/>
new data&#160;<br/>
<b>Figure 72:&#160;</b><br/>
New software version<br/>
<b>Process flow&#160;&#160;<br/>with virtual ECUs</b><br/>
To shorten the iteration cycles, the algorithm is always stimulated with the same data. That&#160;<br/>makes the results with different parameters much more comparable, because the results are&#160;<br/>only influenced by the parameters that&#160;differ.<br/>
This process can of course be automated. The integrated script language of CANape performs an&#160;<br/>analysis of the measurement results, from which parameter calibration settings are derived and&#160;<br/>automatically executed. It is also possible to have the process controlled by an external optimi-<br/>zation tool&#160;such as MATLAB over&#160;the CANape automation&#160;interface.&#160;&#160;<br/>
<hr/>
<a name=97></a>4.6 Shortening Iteration Cycles with Virtual ECUs<br/>
97<br/>
<hr/>
<a name=98></a>98<br/>
<hr/>
<a name=99></a>5 Example of an XCP Implementation<br/>
99<br/>
<b>5 Example of an&#160;XCP Implementation</b><br/>
<hr/>
<a name=100></a>100<br/>
5 Example of an XCP Implementation<br/>
To make it possible for an ECU to communicate over XCP, it is necessary to integrate an XCP driver&#160;<br/>in the ECU’s application. The example described below is of the XCP driver which you can down-<br/>load free of charge at the Download Center of the Vector website (www.vector.com/xcp-driver).&#160;<br/>This packet also contains some sample implementations for various transport layers and tar-<br/>get platforms. The driver consists of the protocol-Layer with the basic functionality needed for&#160;&#160;<br/>measurement and calibration. It does not include features such as Cold Start Measurement,&#160;<br/>Stimulation or flashing. You can purchase a full implementation as a product that is integrated&#160;<br/>in the Vector CANbedded or AUTOSAR environment.<br/>
The XCP protocol layer is placed over the XCP transport layer, which in turn is based on the actual&#160;<br/>bus communication. The&#160;implementation&#160;of the XCP&#160;protocol layer&#160;only consists&#160;of a single&#160;C&#160;<br/>file and a few H files (xcpBasix.c, xcpBasic.h, xcp_def.h and xcp_cfg.h). The examples include&#160;<br/>implementations for various transport layers, e.g. Ethernet and RS232. In the case of CAN, the&#160;<br/>transport layer is normally very simple and the various XCP message types are mapped directly&#160;<br/>to CAN&#160;messages. There are then separate fixed identifiers for the Tx and Rx directions.<br/>
The&#160;software&#160;interface&#160;between&#160;the&#160;transport&#160;and&#160;protocol&#160;layers&#160;is&#160;very&#160;simple.&#160;It&#160;contains&#160;just&#160;<br/>a few functions:<br/>&gt;&#160;&#160;When the Slave receives an XCP message over the bus, it first arrives in the communication&#160;<br/>
driver, which routes the message to the XCP transport layer. The transport layer informs the&#160;<br/>protocol layer about the message&#160;with the function&#160;call XcpCommand().<br/>
&gt;&#160;&#160;If the XCP protocol layer wishes to send a message (e.g. a response to an XCP command from&#160;<br/>
the Master or a DAQ message), the message is routed to the transport layer by a call of the&#160;<br/>ApplXcpSend()&#160;function.<br/>
&gt;&#160;&#160;The transport layer informs the protocol layer that the message was successfully sent by the&#160;<br/>
function call&#160;XcpSendCallBack().<br/>
<hr/>
<a name=101></a>5 Example of an XCP Implementation<br/>
101<br/>
Application<br/>
r<br/>
t<br/>
t<br/>
XcpEvent<br/>
XcpIni<br/>
XcpBackground<br/>
ApplXcpGetPointe<br/>
XCP Protocol Layer&#160;<br/>
ion - XCP Transpor<br/>
k<br/>
at<br/>
Layer Interface&#160;<br/>
d<br/>
Applic<br/>
ommand<br/>
ApplXcpSen<br/>
XcpC<br/>
XcpSendCallbac<br/>
XCP Transport Layer<br/>
Physical Layer<br/>
<b>Figure 73:<br/>Incorporating&#160;</b><br/>
<b>Bus</b><br/>
<b>the XCP Slave&#160;&#160;<br/>in the ECU code</b><br/>
The&#160;interface&#160;between&#160;the&#160;application&#160;and&#160;the&#160;protocol&#160;layer&#160;can&#160;only&#160;be&#160;implemented&#160;via&#160;four&#160;<br/>functions:<br/>&gt;&#160;&#160;The application activates the XCP driver with the help of XcpInit(). This call is made once in&#160;<br/>
the starting process.<br/>
&gt;&#160;&#160;With XcpEvent(), the application informs the XCP driver that a certain event has occurred&#160;<br/>
(e.g. “End of&#160;a computational cycle reached”).<br/>
&gt;&#160;&#160;The call XcpBackground() lets the XCP driver execute certain activities in background (e.g.&#160;<br/>
calculation&#160;of a checksum).<br/>
&gt;&#160;&#160;Since the addresses in A2L files are always defined as 40-bit values (32-bit address, 8-bit&#160;<br/>
address extension), the XCP driver uses the function ApplXcpGetPointer() to obtain a pointer&#160;<br/>from a A2L-conformant address.<br/>
These interfaces are sufficient to integrate basic functionalities for measurement and calibra-<br/>tion. Other interfaces are only needed for extended functions such as page swapping, identifi-<br/>cation or&#160;seed &amp; key. They are described in detail&#160;in documentation&#160;for the driver.<br/>
<hr/>
<a name=102></a>102<br/>
5 Example of an XCP Implementation<br/>
<b>5.1 Description of Functions&#160;</b><br/>
<b>void XcpInit&#160;(void)</b><br/>
Task:&#160;&#160;<br/>Initialize&#160;the XCP driver<br/>
Description:&#160;&#160;<br/>The application activates the XCP driver with XcpInit(). This command must be executed exactly&#160;<br/>once before any&#160;sort of XCP driver&#160;function may be called.<br/>
<b>void XcpEvent&#160;(BYTE event)</b><br/>
Task:<br/>The application&#160;informs&#160;the XCP driver&#160;about which event&#160;occurred. A unique&#160;event number is&#160;<br/>assigned to each event here. &#160;<br/>
Description:<br/>In setting up the measurement configuration in the measurement and calibration tool, the user&#160;<br/>selects which measured values should&#160;be synchronously acquired with which events. The infor-<br/>mation on measured values and events originates from the A2L. The desired measurement con-<br/>figuration&#160;is communicated to the XCP driver in the form&#160;of DAQ lists.&#160;<br/>
Example&#160;of an event definition&#160;in an engine controller:<br/>XcpEvent (1);&#160;<br/>
// Event 1 stands for the 10-ms&#160;task<br/>
XcpEvent (2);&#160;<br/>
// Event&#160;2 stands for the 100-ms&#160;task<br/>
XcpEvent (5);&#160;<br/>
// Event&#160;5 stands for the 1-ms&#160;task<br/>
XcpEvent (8);&#160;<br/>
// Event&#160;8 is used for ignition&#160;angle synchronous measurements<br/>
<b>BYTE XcpBackground&#160;(void)</b><br/>
Task:<br/>Execute background activities&#160;of the XCP driver.&#160;<br/>
Description:<br/>This function should be called periodically in a background or idle task. It is used by the XCP&#160;<br/>driver, for example, to compute the checksum, because the computation of a longer checksum&#160;<br/>in XcpCommand() could take an unacceptably long time. With each call of XcpBackground(), a&#160;<br/>partial checksum of 256 bytes is computed. The duration of a checksum computation therefore&#160;<br/>depends on the call frequency of XcpBackground(). There are no other requirements for the call&#160;<br/>frequency or periodicity. The return value 1 indicates that a checksum computation is currently&#160;<br/>running.&#160;<br/>
<hr/>
<a name=103></a>5.1 Description of Functions&#160;<br/>
103<br/>
<b>void XcpCommand (DWORD* pCommand)</b><br/>
Task:<br/>Interpret an&#160;XCP command.<br/>
Description:<br/>This function must be called each time the transport layer receives a XCP frame. The parameter&#160;<br/>is a pointer to the frame.&#160;<br/>
<b>void ApplXcpSend&#160;(BYTE len, BYTE *msg)</b><br/>
Task:<br/>Transfer&#160;a frame to be sent&#160;to the transport&#160;layer.<br/>
Description:<br/>With this call, the protocol layer sends a message to the transport layer for transmission to the&#160;<br/>Master. The call XcpSendCallBack implements a handshake method between the protocol and&#160;<br/>transport layers.&#160;<br/>
<b>BYTE XcpSendCallBack (void)</b><br/>
Task:<br/>The&#160;protocol&#160;layer&#160;uses&#160;this&#160;callback&#160;to&#160;inform&#160;the&#160;transport&#160;layer&#160;that&#160;the&#160;last&#160;message&#160;that&#160;was&#160;<br/>transferred to ApplXcpSend()&#160;was successfully&#160;transmitted.<br/>
Description:<br/>The protocol layer does not call an ApplXcpSend() command until XcpSendCallBack() indicates&#160;<br/>that&#160;the prior&#160;message&#160;was successfully transmitted.&#160;XcpSendCallBack()&#160;returns&#160;the value&#160;0&#160;<br/>(FALSE) if the XCP driver is in idle. If there are more frames to be sent, ApplXcpSend() is called&#160;<br/>directly&#160;from XcpSendCallBack(). &#160;<br/>
<b>BYTE *ApplXcpGetPointer (BYTE&#160;addr_ext, DWORD addr)</b><br/>
Task:<br/>Convert an A2L-conformant address to a pointer.<br/>
Description:<br/>The function maps the 40-bit A2L-conformant addressing (32-bit address + 8-bit address exten-<br/>sion)&#160;that&#160;is&#160;sent&#160;by&#160;the&#160;XCP&#160;Master&#160;to&#160;a&#160;valid&#160;pointer.&#160;The&#160;address&#160;extension&#160;can&#160;be&#160;used,&#160;for&#160;<br/>example,&#160;to distinguish&#160;different address areas&#160;or memory types.<br/>
<hr/>
<a name=104></a>104<br/>
5 Example of an XCP Implementation<br/>
<b>5.2 Parameterization of&#160;the Driver&#160;</b><br/>
In many respects, the&#160;XCP driver is&#160;scalable and parameterizable to properly&#160;handle the wide&#160;<br/>variety of functional content, transport protocols and target platforms. All settings are made in&#160;<br/>the parameter file xcp_cfg.h.&#160;In the simplest case, they appear as follows:<br/>
/* Define protocol parameters */<br/>#define kXcpMaxCTO &#160; &#160; 8 &#160; &#160; &#160;/* Maximum&#160;CTO Message Length */<br/>#define kXcpMaxDTO &#160; &#160; 8 &#160; &#160; &#160;/* Maximum&#160;DTO Message Length */<br/>#define C_CPUTYPE_BIGENDIAN&#160;&#160; /* byte order Motorola&#160;*/<br/>
/* Enable memory checksum */<br/>#define XCP_ENABLE_CHECKSUM<br/>#define kXcpChecksumMethod XCP_CHECKSUM_TYPE_ADD14<br/>
/* Enable calibration */<br/>#define XCP_ENABLE_CALIBRATION<br/>#define XCP_ENABLE_SHORT_UPLOAD<br/>
/* Enable data acquisition */<br/>#define XCP_ENABLE_DAQ &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;&#160;<br/>#define kXcpDaqMemSize&#160;(512) /* Memory space reserved&#160;for DAQ */<br/>#define XCP_ENABLE_SEND_QUEUE<br/>
For a CAN transport layer, the appropriate CTO and DTO parameters of eight bytes are set. The&#160;<br/>driver must know whether it is running on a platform with Motorola or Intel byte order, in this&#160;<br/>case a Motorola-CPU (Big Endian). The remaining parameters activate the functionalities: mea-<br/>surement, calibration and checksum computation. The algorithm for checksum computation is&#160;<br/>configured (here summing of all bytes into a DWORD) and the parameter of the available mem-<br/>ory is indicated for the measurement (here 512 bytes). The memory is primarily needed to store&#160;<br/>the DAQ lists and to buffer the data during the measurement. The parameter therefore deter-<br/>mines the maximum possible number of measurement signals. In the driver documentation you&#160;<br/>will&#160;find more detailed information on&#160;estimating the&#160;necessary parameters.<br/>
<hr/>
<a name=105></a>5.2 Parameterization of the Driver<br/>
105<br/>
<hr/>
<a name=106></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-106_1.png"/><br/>
106<br/>
The Authors<br/>
<b>The Authors</b><br/>
<b>&#160;</b><br/>
&#160;<br/>
<b>&#160;&#160;Andreas Patzer</b><br/>
Mr. Patzer graduated in Electrical&#160;Engineering&#160;from the Technical University of&#160;<br/>Karlsruhe. In his studies&#160;he specialized&#160;in measurement and control&#160;engineering&#160;<br/>and information and industrial engineering.&#160;In 2003, he joined Vector Informatik&#160;<br/>GmbH in Stuttgart. Andreas&#160;Patzer has supported XCP&#160;projects from the very start,&#160;<br/>since XCP&#160;was standardized by ASAM&#160;e.V. in the&#160;same year he was&#160;hired.&#160;&#160;<br/>He currently manages the Customer&#160;Relations and Services&#160;area as a team leader&#160;<br/>for the Measurement &amp; Calibration product line.&#160;<br/>
<hr/>
<a name=107></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-107_1.png"/><br/>
The Authors<br/>
107<br/>
&#160;<br/>
<b>Rainer&#160;Zaiser</b><br/>
Mr. Zaiser&#160;has a degree in Electrical Engineering&#160;from the University of Stuttgart.&#160;<br/>After&#160;graduating, he came directly to Vector Informatik&#160;GmbH in autumn 1988,&#160;<br/>where he has helped&#160;to create many of the standards that&#160;have become&#160;established&#160;<br/>in the automotive industry such as DBC, MDF, CCP,&#160;A2L and to a large extent XCP.&#160;&#160;<br/>From the start, he headed up the Measurement &amp; Calibration and Network&#160;<br/>Interfaces&#160;product lines.<br/>
<hr/>
<a name=108></a>108<br/>
Table of Abbreviations and Acronyms<br/>
<b>Table of Abbreviations and Acronyms&#160;</b><br/>
A2L&#160;&#160;<br/>
File extension for an ASAM 2MC language file<br/>
AML&#160;&#160;<br/>
ASAM&#160;2 Meta Language<br/>
ASAM&#160;&#160;<br/>
Association&#160;for Standardisation&#160;of Automation&#160;and Measuring Systems<br/>
BYP&#160;&#160;<br/>
Bypassing<br/>
CAL&#160;&#160;<br/>
Calibration<br/>
CAN&#160;&#160;<br/>
Controller&#160;Area Network<br/>
CCP&#160;&#160;<br/>
CAN Calibration Protocol<br/>
CMD&#160;&#160;<br/>
Command<br/>
CS&#160;&#160;<br/>
Checksum<br/>
CTO&#160;&#160;<br/>
Command Transfer Object<br/>
CTR&#160;&#160;<br/>
Counter<br/>
DAQ&#160;&#160;<br/>
Data Acquisition,&#160;Data Acquisition&#160;Packet<br/>
DTO&#160;&#160;<br/>
Data Transfer Object<br/>
ECU&#160;&#160;<br/>
Electronic&#160;Control Unit<br/>
ERR&#160;&#160;<br/>
Error Packet<br/>
EV&#160;&#160;<br/>
Event Packet<br/>
FIBEX&#160;<br/>
Field Bus&#160;Exchange Format&#160;<br/>
LEN&#160;&#160;<br/>
Length<br/>
MCD&#160;&#160;<br/>
Measurement&#160;Calibration and Diagnostics<br/>
MTA&#160;&#160;<br/>
Memory&#160;Transfer Address<br/>
ODT&#160;&#160;<br/>
Object Descriptor Table<br/>
PAG&#160;&#160;<br/>
Paging<br/>
PGM&#160;&#160;<br/>
Programming<br/>
PID&#160;&#160;<br/>
Packet Identifier<br/>
RES&#160;&#160;<br/>
Command Response&#160;Packet<br/>
SERV&#160;&#160;<br/>
Service&#160;Request Packet<br/>
SPI&#160;&#160;<br/>
Serial&#160;Peripheral Interface<br/>
STD&#160;&#160;<br/>
Standard<br/>
STIM&#160;&#160;<br/>
Data Stimulation&#160;Packet<br/>
TCP/IP&#160;&#160;<br/>
Transfer&#160;Control Protocol&#160;/&#160;Internet Protocol<br/>
TS&#160;&#160;<br/>
Time Stamp<br/>
UDP/IP&#160;&#160;<br/>
Unified Data Protocol&#160;/&#160;Internet&#160;Protocol<br/>
USB&#160;&#160;<br/>
Universal Serial Bus<br/>
XCP&#160;&#160;<br/>
Universal Measurement and Calibration&#160;Protocol<br/>
Download&#160;<br/>
Sending of data&#160;from Master to&#160;Slave&#160;<br/>
Upload&#160;<br/>
Sending of data&#160;from Slave to Master<br/>
<hr/>
<a name=109></a>Literature &amp; Web Addresses&#160;<br/>
109<br/>
<b>Literature&#160;</b><br/>
XCP is specified by ASAM (Association for Standardisation of Automation and Measuring Systems).&#160;<br/>You will&#160;find details on the protocol and on ASAM&#160;at:&#160;<b>www.asam.net</b><br/>
<b>Web Addresses&#160;</b><br/>
Standardization&#160;committees:<br/>&gt;&#160;&#160;ASAM, XCP protocol-specific documents, A2L&#160;specification,&#160;<b>www.asam.net</b><br/>
Supplier&#160;of development software:<br/>&gt;&#160;&#160;MathWorks, information&#160;on MATLAB, Simulink&#160;and Simulink&#160;Coder,&#160;<b>www.mathworks.com</b>&#160;<br/>&gt;&#160;&#160;Vector Informatik GmbH, demo version of CANape, free of charge and openly available XCP&#160;<br/>
driver (basic version), comprehensive information on the topics of ECU calibration, testing&#160;<br/>and simulation,&#160;<b>www.vector.com</b><br/>
<hr/>
<a name=110></a>110<br/>
Table of Figures<br/>
<b>Table of Figures&#160;</b><br/>
Figure 1: Fundamental communication&#160;with a runtime&#160;environment&#160;<br/>
8<br/>
Figure 2: The Interface Model of&#160;ASAM&#160;<br/>
9<br/>
Figure 3: An&#160;XCP Master can simultaneously communicate with&#160;multiple Slaves&#160;<br/>
10<br/>
Figure 4: Subdivision&#160;of the XCP protocol into protocol&#160;layer and transport layer&#160;<br/>
14<br/>
Figure 5: XCP Slaves&#160;can be used in many different runtime&#160;environments&#160;<br/>
15<br/>
Figure 6: XCP packet&#160;<br/>
19<br/>
Figure 7: Overview of XCP Packet Identifier (PID)&#160;<br/>
19<br/>
Figure 8: XCP communication&#160;model&#160;with CTO/DTO&#160;<br/>
20<br/>
Figure 9: Message&#160;identification&#160;<br/>
21<br/>
Figure 10: Time&#160;stamp&#160;<br/>
21<br/>
Figure 11: Data field in the XCP packet&#160;<br/>
22<br/>
Figure 12: The three modes of the XCP protocol: Standard,&#160;Block and Interleaved&#160;mode&#160;<br/>
24&#160;<br/>
Figure 13: Overview of the CTO packet structure&#160;<br/>
25<br/>
Figure 14: Trace&#160;example from&#160;a calibration process&#160;<br/>
30<br/>
Figure 15: Transfer of a parameter set file to&#160;an ECU’s RAM&#160;<br/>
31<br/>
Figure 16: Hex&#160;window&#160;<br/>
32<br/>
Figure 17: Address information of the parameter&#160;“Triangle” from the A2L file&#160;<br/>
33<br/>
Figure 18: Polling&#160;communication&#160;in the CANape Trace&#160;window&#160;<br/>
34<br/>
Figure 19: Events&#160;in the ECU&#160;<br/>
35<br/>
Figure 20: Event definition in an&#160;A2L&#160;<br/>
35<br/>
Figure 21: Allocation&#160;of “Triangle”&#160;to possible events&#160;in the A2L&#160;<br/>
36<br/>
Figure 22: Selecting&#160;events (measurement&#160;mode) for each measurement parameter&#160;<br/>
36<br/>
Figure 23: Excerpt from the CANape Trace window of a DAQ measurement&#160;<br/>
37<br/>
Figure 24: ODT: Allocation&#160;of RAM&#160;addresses to DAQ DTO&#160;<br/>
38<br/>
Figure 25: DAQ list with three ODTs&#160;<br/>
39<br/>
Figure 26: Static DAQ lists&#160;<br/>
39<br/>
Figure 27: Dynamic&#160;DAQ lists&#160;<br/>
40<br/>
Figure 28: Event for DAQ and STIM&#160;<br/>
41<br/>
Figure 29: Structure of the XCP&#160;packet for DTO transmissions&#160;<br/>
42<br/>
Figure 30: Identification field&#160;with absolute ODT numbers&#160;<br/>
43<br/>
Figure 31: ID field with relative ODT and absolute DAQ numbers (one&#160;byte)&#160;<br/>
43<br/>
Figure 32: ID field with relative ODT and absolute DAQ numbers&#160;(two bytes)&#160;<br/>
43<br/>
Figure 33:&#160;ID field&#160;with relative ODT and absolute DAQ numbers as well&#160;as fill byte&#160;<br/>&#160;<br/>
(total of&#160;four bytes)&#160;<br/>
44<br/>
Figure 34: Definition of which bus nodes send which messages&#160;<br/>
45<br/>
Figure 35: Representation&#160;of a CAN network&#160;<br/>
46<br/>
Figure 36: Example of XCP-on-CAN&#160;communication&#160;<br/>
47<br/>
Figure 37: Representation&#160;of an XCP-on-CAN&#160;message&#160;<br/>
47<br/>
Figure 38: Illustration of a CAN FD frame&#160;<br/>
48<br/>
Figure 39: Nodes&#160;K and L are redundantly interconnected&#160;<br/>
50<br/>
Figure 40: Communication&#160;by slot&#160;definition&#160;<br/>
50<br/>
Figure 41: Representation&#160;of a FlexRay communication&#160;matrix&#160;<br/>
51<br/>
Figure 42: Representation&#160;of the FlexRay LPDUs&#160;<br/>
52<br/>
Figure 43: Allocation&#160;of XCP communication&#160;to LPDUs&#160;<br/>
53<br/>
Figure 44: XCP&#160;packet with TCP/IP or UDP/IP&#160;<br/>
54<br/>
<hr/>
<a name=111></a>Table of Figures<br/>
111<br/>
Figure 45: XCP-on-SxI&#160;packet&#160;<br/>
55<br/>
Figure 46: Memory representation&#160;<br/>
56<br/>
Figure 47: Representation&#160;of driver settings&#160;for the flash area&#160;<br/>
58<br/>
Figure 48: Representation&#160;of the block&#160;transfer mode&#160;<br/>
61<br/>
Figure 49: Parameters in a&#160;calibration window&#160;<br/>
66<br/>
Figure 50: Signal&#160;response over time&#160;<br/>
66<br/>
Figure 51: Initial&#160;parameter setting in RAM&#160;<br/>
76<br/>
Figure 52: Initial&#160;situation&#160;after booting&#160;<br/>
80<br/>
Figure 53: Pointer change and copying&#160;to RAM&#160;<br/>
81<br/>
Figure 54: Pointer table for individual&#160;parameters&#160;<br/>
81<br/>
Figure 55: Double&#160;pointer concept&#160;<br/>
83<br/>
Figure 56: Application&#160;areas and application&#160;cases&#160;<br/>
86<br/>
Figure 57: Plants&#160;and controllers&#160;<br/>
86<br/>
Figure 58: Model&#160;in the Loop in Simulink&#160;<br/>
87<br/>
Figure 59: CANape as measurement and&#160;calibration tool&#160;with Simulink&#160;models&#160;<br/>
87<br/>
Figure 60: Software in the Loop with Simulink&#160;environment&#160;<br/>
88<br/>
Figure 61: CANape&#160;as SIL development&#160;platform&#160;<br/>
88<br/>
Figure 62: HIL&#160;solution&#160;<br/>
89<br/>
Figure 63: HIL&#160;with CANape as&#160;measurement and calibration tool&#160;<br/>
89<br/>
Figure 64: CANoe as HIL system&#160;<br/>
90<br/>
Figure 65: CANoe as HIL system with XCP access&#160;to the ECU&#160;<br/>
90<br/>
Figure 66: CANape as HIL solution&#160;<br/>
91<br/>
Figure 67: RCP solution&#160;<br/>
91<br/>
Figure 68: Basic&#160;principle of&#160;bypassing&#160;<br/>
92<br/>
Figure 69: Bypassing&#160;flow&#160;<br/>
93<br/>
Figure 70: Bypassing&#160;with real-time&#160;bypassing hardware and fast ECU access&#160;<br/>
94<br/>
Figure 71: Short&#160;calibration cycles&#160;with virtual ECUs&#160;<br/>
95<br/>
Figure 72: Process&#160;flow with&#160;virtual ECUs&#160;<br/>
96<br/>
Figure 73: Incorporating the XCP Slave in&#160;the ECU code&#160;<br/>
101<br/>
<hr/>
<a name=112></a>112<br/>
Appendix – XCP Solutions at Vector<br/>
<b>Appendix – XCP Solutions at Vector&#160;</b><br/>
Vector made a significant effort in giving shape to the XCP standard. Its extensive know-how&#160;<br/>and vast experience were utilized&#160;to provide comprehensive XCP support:<br/>
<b>Tools<br/></b>&gt;&#160;&#160;The&#160;primary&#160;use&#160;area&#160;of&#160;<b>CANape</b>&#160;is&#160;in&#160;optimal&#160;parameterization&#160;(calibration)&#160;of&#160;electronic&#160;<br/>
control units (ECUs). During the system’s runtime, you calibrate parameter values and simul-<br/>taneously acquire measured signals. The physical interface between CANape and the ECU is&#160;<br/>over XCP (for all&#160;standardized transport protocols) or&#160;CCP.&#160;<br/>
&gt;&#160;&#160;&#160;Complete tool chain for generating and managing the necessary A2L description files (<b>ASAP2&#160;</b><br/>
<b>Tool-Set</b>&#160;and&#160;<b>CANape</b>&#160;with the&#160;<b>ASAP2&#160;Editor</b>&#160;that is&#160;also available as a stand-alone tool).<br/>
&gt;&#160;&#160;&#160;You&#160;&#160;use&#160;&#160;<b>CANoe.XCP</b>&#160;to access&#160;internal ECU&#160;values for testing&#160;and analysis&#160;tasks.<br/>
<b>ECU interfaces<br/></b>The&#160;<b>VX1000</b>&#160;measurement and calibration hardware offers the option of equipping ECUs with&#160;<br/>an XCP-on-Ethernet interface. This&#160;involves connecting&#160;a Plug on Device&#160;(POD) to the ECU for&#160;<br/>direct access to the controller, e.g. over DAP, JTAG, Nexus, etc. The POD transmits the data to a&#160;<br/>base module, which operates as an XCP Slave and provides the data to the XCP Master on the PC&#160;<br/>over XCP on Ethernet. This makes it unnecessary to have an XCP Slave in the ECU. The user ben-<br/>efits from a high measurement data throughput rate of up to 30 Mbyte/sec and short measure-<br/>ment intervals of less than 15 µs.<br/>
<b>Embedded&#160;Software<br/></b>Communication&#160;modules with separate transport layers for CAN, FlexRay and&#160;Ethernet:<br/>&gt;&#160;&#160;<b>XCP Basic</b>&#160;– free download at www.vector.com/xcp-driver, only contains basic XCP functions.&#160;<br/>
Configuration of the XCP protocol and modification of the transport layer are performed man-<br/>ually in the source code. You need to&#160;integrate XCP Basic&#160;in your project yourself.<br/>
&gt;&#160;&#160;<b>XCP Professional</b>&#160;– contains useful extensions to the ASAM specification and enables tool-<br/>
based configuration. Available&#160;for Vector CANbedded&#160;basic software.<br/>
&gt;&#160;&#160;<b>MICROSAR XCP</b>&#160;– contains the functional features of XCP Professional and is based on AUTO-<br/>
SAR specifications. Available for Vector MICROSAR basic software.<br/>
<b>Services<br/></b>&gt;&#160;&#160;<b>Consultation</b>&#160;for using XCP in&#160;your projects&#160;<br/>&gt;&#160;&#160;<b>Integration</b>&#160;of XCP in your ECU<br/>
<b>Training<br/></b>&gt;&#160;&#160;You can learn about the underlying mechanisms and models of the protocol in the “<b>XCP Funda-</b><br/>
<b>mentals Seminar</b>”.<br/>
&gt;&#160;&#160;In the “<b>CANape with XCP on FlexRay Workshop</b>” you learn about FlexRay fundamentals&#160;<br/>
and&#160;the&#160;special&#160;aspects&#160;of XCP&#160;on&#160;FlexRay&#160;are explained,&#160;in&#160;particular&#160;dynamic&#160;bandwidth&#160;<br/>management.<br/>
<hr/>
<a name=113></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-113_1.png"/><br/>
Appendix – XCP Solutions at Vector<br/>
113<br/>
<b>Special&#160;XCP support by CANape<br/></b>CANape was the first MCD tool to support the XCP 1.0 specification and was also the first XCP on&#160;<br/>FlexRay&#160;Master on the market.<br/>
A special technical feature of XCP on FlexRay is dynamic bandwidth management. Here, CANape&#160;<br/>identifies the available bandwidth provided for XCP in the FlexRay ClusterP and it allocates&#160;<br/>this bandwidth to the momentary application data traffic dynamically and very efficiently. The&#160;<br/>available bandwidth is thereby optimally used&#160;for XCP communication.&#160;<br/>
Moreover, CANape has a DLL interface. It enables support of XCP on any desired (user-defined)&#160;<br/>transport layer. This&#160;lets&#160;you integrate&#160;any&#160;desired&#160;test&#160;instrumentation&#160;or&#160;proprietary&#160;pro-<br/>tocols&#160;in&#160;CANape. A&#160;code&#160;generator&#160;supports&#160;you in&#160;creating&#160;the&#160;XCP-specific&#160;share&#160;of such a&#160;<br/>driver.<br/>
<hr/>
<a name=114></a>114<br/>
Index<br/>
<b>Index</b><br/>
<b>A</b><br/>
<b>F</b><br/>
A2L&#160;<br/>
9,&#160;10,&#160;25,&#160;33,&#160;35,&#160;39,&#160;40,&#160;41,&#160;52,&#160;&#160;FIBEX&#160;<br/>
51,&#160;52,&#160;53<br/>
&#160;<br/>
53,&#160;57,&#160;58,&#160;63,&#160;65,&#160;66,&#160;67,&#160;68,&#160;69,&#160;&#160;Flash memory&#160;<br/>
16,&#160;17,&#160;56,&#160;57,&#160;58,&#160;59,&#160;62<br/>
&#160;<br/>
70,&#160;88,&#160;102,&#160;103,&#160;108<br/>
FLX_CHANNEL&#160;<br/>
52<br/>
Address extension&#160;<br/>
29,&#160;33,&#160;38,&#160;101,&#160;103<br/>
FLX_LPDU_ID&#160;<br/>
52<br/>
AML&#160;<br/>
25,&#160;68,&#160;108<br/>
FLX_SLOT_ID&#160;<br/>
52<br/>
ASAM&#160;<br/>
7,&#160;8,&#160;9,&#160;55,&#160;108<br/>
Fullpassing&#160;<br/>
92<br/>
ASAP2 Tool-Set&#160;<br/>
70<br/>
<b>G</b><br/>
<b>B</b><br/>
GET_CAL_PAGE&#160;<br/>
25,&#160;57<br/>
Bandwith&#160;optimization&#160;<br/>
34<br/>
GET_DAQ_PROCESSOR_INFO&#160;<br/>
44,&#160;60,&#160;71<br/>
Bus load&#160;<br/>
34<br/>
BYP&#160;<br/>
108<br/>
<b>H</b><br/>
Bypassing&#160;<br/>
44,&#160;92,&#160;93,&#160;94<br/>
HIL&#160;<br/>
86,&#160;89,&#160;90,&#160;91<br/>
<b>C</b><br/>
<b>L</b><br/>
CAN&#160;<br/>
7,&#160;8,&#160;14,&#160;24,&#160;29,&#160;33,&#160;38,&#160;45,&#160;46,&#160;47,&#160;&#160;Linking&#160;<br/>
74,&#160;88<br/>
&#160;<br/>
51,&#160;69,&#160;94,&#160;108<br/>
LPDU&#160;<br/>
52<br/>
CAN FD&#160;<br/>
48&#160;<br/>
CANape&#160;<br/>
95<br/>
<b>M</b><br/>
CANoe&#160;<br/>
95<br/>
MIL&#160;<br/>
87<br/>
CANoe.XCP&#160;<br/>
95<br/>
MTA&#160;<br/>
30,&#160;108<br/>
CCP&#160;<br/>
7,&#160;8,&#160;39,&#160;45,&#160;108<br/>
CMD&#160;<br/>
20,&#160;25,&#160;52,&#160;108<br/>
<b>O</b><br/>
Compiling&#160;<br/>
95<br/>
ODT&#160;<br/>
37,&#160;38,&#160;39,&#160;40,&#160;42,&#160;43,&#160;44,&#160;60,&#160;<br/>
CTO&#160;<br/>
20,&#160;21,&#160;22,&#160;25,&#160;108<br/>
&#160;<br/>
71,&#160;108<br/>
CTR&#160;<br/>
54,&#160;55,&#160;108<br/>
OFFSET&#160;<br/>
52<br/>
CYCLE_REPETITION&#160;<br/>
52<br/>
<b>P</b><br/>
<b>D</b><br/>
PAG&#160;<br/>
108<br/>
DAQ&#160;<br/>
22,&#160;32,&#160;33,&#160;34,&#160;35,&#160;36,&#160;37,&#160;38,&#160;&#160;Page&#160;<br/>
95<br/>
&#160;<br/>
39,&#160;40,&#160;41,&#160;42,&#160;43,&#160;44,&#160;60,&#160;62,&#160;71,&#160;&#160;PGM&#160;<br/>
108<br/>
&#160;<br/>
93,&#160;94,&#160;100,&#160;102,&#160;108<br/>
PID&#160;<br/>
8,&#160;19,&#160;21,&#160;25,&#160;42,&#160;108<br/>
DBC&#160;<br/>
45<br/>
Polling&#160;<br/>
33,&#160;34,&#160;36<br/>
DOWNLOAD&#160;<br/>
30,&#160;31,&#160;61<br/>
DTO&#160;<br/>
20,&#160;21,&#160;22,&#160;33,&#160;37,&#160;38,&#160;42,&#160;108<br/>
<b>R<br/></b>RAM&#160;<br/>
16,&#160;17,&#160;18,&#160;30,&#160;31,&#160;37,&#160;38,&#160;39,&#160;<br/>
<b>E</b><br/>
&#160;<br/>
58,&#160;62,&#160;74,&#160;76,&#160;79,&#160;80,&#160;82<br/>
ECU&#160;<br/>
9,&#160;68,&#160;90,&#160;92,&#160;93,&#160;108<br/>
Reboot&#160;<br/>
32<br/>
EEPROM&#160;<br/>
16,&#160;31,&#160;62<br/>
RES&#160;<br/>
20,&#160;21,&#160;28,&#160;52,&#160;108<br/>
ERR&#160;<br/>
20,&#160;25,&#160;28,&#160;108<br/>
EV&#160;<br/>
29,&#160;108<br/>
Event&#160;<br/>
35,&#160;39,&#160;41,&#160;60,&#160;62,&#160;71,&#160;102<br/>
<hr/>
<a name=115></a>Index<br/>
115<br/>
<b>S<br/></b>Segment&#160;<br/>
57,&#160;58<br/>
SEGMENT_NUMBER&#160;<br/>
57<br/>
SERV&#160;<br/>
29,&#160;108<br/>
SET_CAL_PAGE&#160;<br/>
25,&#160;57<br/>
SHORT_UPLOAD&#160;<br/>
30,&#160;33,&#160;61<br/>
SIL&#160;<br/>
86,&#160;88<br/>
STIM&#160;<br/>
33,&#160;41,&#160;42,&#160;44,&#160;60,&#160;71,&#160;93,&#160;<br/>
&#160;<br/>
94,&#160;95,&#160;108<br/>
Stimulation&#160;<br/>
29,&#160;63,&#160;95<br/>
<b>T<br/></b>Task&#160;<br/>
102<br/>
TCP/IP&#160;<br/>
53,&#160;54,&#160;108<br/>
<b>U<br/></b>UDP/IP&#160;<br/>
53,&#160;54,&#160;108<br/>
USB&#160;<br/>
55,&#160;108<br/>
<b>V<br/></b>VN8900&#160;<br/>
95<br/>
VX&#160;<br/>
94<br/>
VX1000&#160;<br/>
95<br/>
<hr/>
<a name=116></a><img src="ElectricPowerSteering_RH850_FORD_T3T6_website/content/en/docs/Xcp/doc/XCP_ReferenceBook_V2.0_EN-116_1.png"/><br/>
<b>Get more Information!</b><br/>
<b>Visit our Website for:</b><br/>
&gt;&#160; News<br/>
&gt;&#160; Products<br/>
&gt;&#160; Demo Software<br/>
&gt;&#160; Support<br/>
&gt;&#160; Trainings Classes<br/>
&gt;&#160; Addresses<br/>
<b>www.vector.com</b><br/>
14<br/>
V 2.0 4/20<br/>
<hr/>
<a name="outline"></a><h1>Document Outline</h1>
<ul>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#5">Table of Contents</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#7">Introduction</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#13">1 Fundamentals of the XCP Protocol</a>
<ul>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#19">1.1 XCP Protocol Layer</a>
<ul>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#21">1.1.1 Identification Field</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#21">1.1.2 Time Stamp</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#22">1.1.3 Data Field</a></li>
</ul>
</li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#22">1.2 Exchange of CTOs</a>
<ul>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#22">1.2.1 XCP Command Structure</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#25">1.2.2 CMD</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#28">1.2.3 RES</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#28">1.2.4 ERR</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#29">1.2.5 EV</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#29">1.2.6 SERV</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#29">1.2.7 Calibrating Parameters in the Slave</a></li>
</ul>
</li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#32">1.3 Exchanging DTOs – Synchronous Data Exchange</a>
<ul>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#33">1.3.1 Measurement Methods: Polling versus DAQ</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#34">1.3.2 DAQ Measurement Method</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#41">1.3.3 STIM Calibration Method</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#42">1.3.4 XCP Packet Addressing for DAQ and STIM</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#44">1.3.5 Bypassing = DAQ + STIM</a></li>
</ul>
</li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#45">1.4 XCP Transport Layers</a>
<ul>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#45">1.4.1 CAN</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#48">1.4.2 CAN FD</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#50">1.4.3 FlexRay</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#53">1.4.4 Ethernet</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#55">1.4.5 SxI</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#55">1.4.6 USB</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#55">1.4.7 LIN</a></li>
</ul>
</li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#56">1.5 XCP Services</a>
<ul>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#56">1.5.1 Memory Page Swapping</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#58">1.5.2 Saving Memory Pages – Data Page Freezing</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#58">1.5.3 Flash Programming</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#60">1.5.4 Automatic Detection of the Slave</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#61">1.5.5 Block Transfer Mode for Upload, Download and Flashing</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#62">1.5.6 Cold Start Measurement (start of measurement during power-on)</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#63">1.5.7 Security Mechanisms with XCP</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#65">2 ECU Description File A2L</a>
<ul>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#68">2.1 Setting Up an A2L File for an XCP Slave</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#69">2.2 Manually Creating an A2L File</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#70">2.3 A2L Contents versus ECU Implementation</a></li>
</ul>
</li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#73">3 Calibration Concepts</a>
<ul>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#74">3.1 Parameters in Flash</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#76">3.2 Parameters in RAM</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#78">3.3 Flash Overlay</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#79">3.4 Dynamic Flash Overlay Allocation</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#80">3.5 RAM Pointer Based Calibration Concept per AUTOSAR</a>
<ul>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#80">3.5.1 Single Pointer Concept</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#82">3.5.2 Double Pointer Concept</a></li>
</ul>
</li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#83">3.6 Flash Pointer Based Calibration Concept</a></li>
</ul>
</li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#85">4 Application Areas of XCP</a>
<ul>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#87">4.1 MIL: Model in the Loop</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#88">4.2 SIL: Software in the Loop</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#89">4.3 HIL: Hardware in the Loop</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#91">4.4 RCP: Rapid Control Prototyping</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#92">4.5 Bypassing</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#95">4.6 Shortening Iteration Cycles with Virtual ECUs</a></li>
</ul>
</li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#99">5 Example of an XCP Implementation</a>
<ul>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#102">5.1 Description of Functions</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#104">5.2 Parameterization of the Driver</a></li>
</ul>
</li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#106">The Authors</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#108">Table of Abbreviations and Acronyms</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#109">Literature</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#109">Web Addresses</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#110">Table of Figures</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#112">Appendix – XCP Solutions at Vector</a></li>
<li><a href="XCP_ReferenceBook_V2.0_ENs.html#114">Index</a></li>
</ul>
<hr/>
</body>
</html>
